{
  "version": 3,
  "file": "lazyLoad.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/hooks/lazyLoad.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "import { Transition } from '../transition/transition';\nimport { TransitionService } from '../transition/transitionService';\nimport { TransitionHookFn } from '../transition/interface';\nimport { StateDeclaration, LazyLoadResult } from '../state/interface';\nimport { services } from '../common/coreservices';\nimport { StateRule } from '../url/interface';\n\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n */\nconst lazyLoadHook: TransitionHookFn = (transition: Transition) => {\n  const router = transition.router;\n\n  function retryTransition() {\n    if (transition.originalTransition().options().source !== 'url') {\n      // The original transition was not triggered via url sync\n      // The lazy state should be loaded now, so re-try the original transition\n      const orig = transition.targetState();\n      return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n    }\n\n    // The original transition was triggered via url sync\n    // Run the URL rules and find the best match\n    const $url = router.urlService;\n    const result = $url.match($url.parts());\n    const rule = result && result.rule;\n\n    // If the best match is a state, redirect the transition (instead\n    // of calling sync() which supersedes the current transition)\n    if (rule && rule.type === 'STATE') {\n      const state = (rule as StateRule).state;\n      const params = result.match;\n      return router.stateService.target(state, params, transition.options());\n    }\n\n    // No matching state found, so let .sync() choose the best non-state match/otherwise\n    router.urlService.sync();\n  }\n\n  const promises = transition\n    .entering()\n    .filter((state) => !!state.$$state().lazyLoad)\n    .map((state) => lazyLoadState(transition, state));\n\n  return services.$q.all(promises).then(retryTransition);\n};\n\nexport const registerLazyLoadHook = (transitionService: TransitionService) =>\n  transitionService.onBefore({ entering: (state) => !!state.lazyLoad }, lazyLoadHook);\n\n/**\n * Invokes a state's lazy load function\n *\n * @param transition a Transition context\n * @param state the state to lazy load\n * @returns A promise for the lazy load result\n */\nexport function lazyLoadState(transition: Transition, state: StateDeclaration): Promise<LazyLoadResult> {\n  const lazyLoadFn = state.$$state().lazyLoad;\n\n  // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n  let promise = lazyLoadFn['_promise'];\n  if (!promise) {\n    const success = (result) => {\n      delete state.lazyLoad;\n      delete state.$$state().lazyLoad;\n      delete lazyLoadFn['_promise'];\n      return result;\n    };\n\n    const error = (err) => {\n      delete lazyLoadFn['_promise'];\n      return services.$q.reject(err);\n    };\n\n    promise = lazyLoadFn['_promise'] = services.$q\n      .when(lazyLoadFn(transition, state))\n      .then(updateStateRegistry)\n      .then(success, error);\n  }\n\n  /** Register any lazy loaded state definitions */\n  function updateStateRegistry(result: LazyLoadResult) {\n    if (result && Array.isArray(result.states)) {\n      result.states.forEach((_state) => transition.router.stateRegistry.register(_state));\n    }\n    return result;\n  }\n\n  return promise;\n}\n"
  ]
}