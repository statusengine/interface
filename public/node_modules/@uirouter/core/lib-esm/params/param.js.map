{
  "version": 3,
  "file": "param.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/params/param.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "import { extend, filter, map, allTrueR, find } from '../common/common';\nimport { prop } from '../common/hof';\nimport { isInjectable, isDefined, isString, isArray, isUndefined } from '../common/predicates';\nimport { RawParams, ParamDeclaration } from '../params/interface';\nimport { services } from '../common/coreservices';\nimport { ParamType } from './paramType';\nimport { ParamTypes } from './paramTypes';\nimport { StateDeclaration } from '../state';\nimport { UrlConfig } from '../url';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nconst isShorthand = (cfg: ParamDeclaration) =>\n  ['value', 'type', 'squash', 'array', 'dynamic'].filter(hasOwn.bind(cfg || {})).length === 0;\n\nenum DefType {\n  PATH,\n  SEARCH,\n  CONFIG,\n}\nexport { DefType };\n\nfunction getParamDeclaration(paramName: string, location: DefType, state: StateDeclaration): ParamDeclaration {\n  const noReloadOnSearch = (state.reloadOnSearch === false && location === DefType.SEARCH) || undefined;\n  const dynamic = find([state.dynamic, noReloadOnSearch], isDefined);\n  const defaultConfig = isDefined(dynamic) ? { dynamic } : {};\n  const paramConfig = unwrapShorthand(state && state.params && state.params[paramName]);\n  return extend(defaultConfig, paramConfig);\n}\n\nfunction unwrapShorthand(cfg: ParamDeclaration): ParamDeclaration {\n  cfg = isShorthand(cfg) ? ({ value: cfg } as ParamDeclaration) : cfg;\n\n  getStaticDefaultValue['__cacheable'] = true;\n  function getStaticDefaultValue() {\n    return cfg.value;\n  }\n\n  const $$fn = isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue;\n  return extend(cfg, { $$fn });\n}\n\nfunction getType(cfg: ParamDeclaration, urlType: ParamType, location: DefType, id: string, paramTypes: ParamTypes) {\n  if (cfg.type && urlType && urlType.name !== 'string') throw new Error(`Param '${id}' has two type configurations.`);\n  if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type as string))\n    return paramTypes.type(cfg.type as string);\n  if (urlType) return urlType;\n  if (!cfg.type) {\n    const type =\n      location === DefType.CONFIG\n        ? 'any'\n        : location === DefType.PATH\n        ? 'path'\n        : location === DefType.SEARCH\n        ? 'query'\n        : 'string';\n    return paramTypes.type(type);\n  }\n  return cfg.type instanceof ParamType ? cfg.type : paramTypes.type(cfg.type as string);\n}\n\n/** returns false, true, or the squash value to indicate the \"default parameter url squash policy\". */\nfunction getSquashPolicy(config: ParamDeclaration, isOptional: boolean, defaultPolicy: boolean | string) {\n  const squash = config.squash;\n  if (!isOptional || squash === false) return false;\n  if (!isDefined(squash) || squash == null) return defaultPolicy;\n  if (squash === true || isString(squash)) return squash;\n  throw new Error(`Invalid squash policy: '${squash}'. Valid policies: false, true, or arbitrary string`);\n}\n\nfunction getReplace(config: ParamDeclaration, arrayMode: boolean, isOptional: boolean, squash: string | boolean) {\n  const defaultPolicy = [\n    { from: '', to: isOptional || arrayMode ? undefined : '' },\n    { from: null, to: isOptional || arrayMode ? undefined : '' },\n  ];\n\n  const replace = isArray(config.replace) ? config.replace : [];\n  if (isString(squash)) replace.push({ from: squash, to: undefined });\n\n  const configuredKeys = map(replace, prop('from'));\n  return filter(defaultPolicy, (item) => configuredKeys.indexOf(item.from) === -1).concat(replace);\n}\n\nexport class Param {\n  id: string;\n  type: ParamType;\n  location: DefType;\n  isOptional: boolean;\n  dynamic: boolean;\n  raw: boolean;\n  squash: boolean | string;\n  replace: [{ to: any; from: any }];\n  inherit: boolean;\n  array: boolean;\n  config: any;\n  /** Cache the default value if it is a static value */\n  _defaultValueCache: {\n    defaultValue: any;\n  };\n\n  static values(params: Param[], values: RawParams = {}): RawParams {\n    const paramValues = {} as RawParams;\n    for (const param of params) {\n      paramValues[param.id] = param.value(values[param.id]);\n    }\n    return paramValues;\n  }\n\n  /**\n   * Finds [[Param]] objects which have different param values\n   *\n   * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n   *\n   * @param params: The list of Param objects to filter\n   * @param values1: The first set of parameter values\n   * @param values2: the second set of parameter values\n   *\n   * @returns any Param objects whose values were different between values1 and values2\n   */\n  static changed(params: Param[], values1: RawParams = {}, values2: RawParams = {}): Param[] {\n    return params.filter((param) => !param.type.equals(values1[param.id], values2[param.id]));\n  }\n\n  /**\n   * Checks if two param value objects are equal (for a set of [[Param]] objects)\n   *\n   * @param params The list of [[Param]] objects to check\n   * @param values1 The first set of param values\n   * @param values2 The second set of param values\n   *\n   * @returns true if the param values in values1 and values2 are equal\n   */\n  static equals(params: Param[], values1 = {}, values2 = {}): boolean {\n    return Param.changed(params, values1, values2).length === 0;\n  }\n\n  /** Returns true if a the parameter values are valid, according to the Param definitions */\n  static validates(params: Param[], values: RawParams = {}): boolean {\n    return params.map((param) => param.validates(values[param.id])).reduce(allTrueR, true);\n  }\n\n  constructor(id: string, type: ParamType, location: DefType, urlConfig: UrlConfig, state: StateDeclaration) {\n    const config: ParamDeclaration = getParamDeclaration(id, location, state);\n    type = getType(config, type, location, id, urlConfig.paramTypes);\n    const arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n    const isOptional = config.value !== undefined || location === DefType.SEARCH;\n    const dynamic = isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n    const raw = isDefined(config.raw) ? !!config.raw : !!type.raw;\n    const squash = getSquashPolicy(config, isOptional, urlConfig.defaultSquashPolicy());\n    const replace = getReplace(config, arrayMode, isOptional, squash);\n    const inherit = isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      const arrayDefaults = { array: location === DefType.SEARCH ? 'auto' : false };\n      const arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    extend(this, { id, type, location, isOptional, dynamic, raw, squash, replace, inherit, array: arrayMode, config });\n  }\n\n  isDefaultValue(value: any): boolean {\n    return this.isOptional && this.type.equals(this.value(), value);\n  }\n\n  /**\n   * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n   * default value, which may be the result of an injectable function.\n   */\n  value(value?: any): any {\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    const getDefaultValue = () => {\n      if (this._defaultValueCache) return this._defaultValueCache.defaultValue;\n\n      if (!services.$injector) throw new Error('Injectable functions cannot be called at configuration time');\n\n      const defaultValue = services.$injector.invoke(this.config.$$fn);\n\n      if (defaultValue !== null && defaultValue !== undefined && !this.type.is(defaultValue))\n        throw new Error(\n          `Default value (${defaultValue}) for parameter '${this.id}' is not an instance of ParamType (${this.type.name})`\n        );\n\n      if (this.config.$$fn['__cacheable']) {\n        this._defaultValueCache = { defaultValue };\n      }\n\n      return defaultValue;\n    };\n\n    const replaceSpecialValues = (val: any) => {\n      for (const tuple of this.replace) {\n        if (tuple.from === val) return tuple.to;\n      }\n      return val;\n    };\n\n    value = replaceSpecialValues(value);\n\n    return isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);\n  }\n\n  isSearch(): boolean {\n    return this.location === DefType.SEARCH;\n  }\n\n  validates(value: any): boolean {\n    // There was no parameter value, but the param is optional\n    if ((isUndefined(value) || value === null) && this.isOptional) return true;\n\n    // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n    const normalized = this.type.$normalize(value);\n    if (!this.type.is(normalized)) return false;\n\n    // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n    const encoded = this.type.encode(normalized);\n    return !(isString(encoded) && !this.type.pattern.exec(<string>encoded));\n  }\n\n  toString() {\n    return `{Param:${this.id} ${this.type} squash: '${this.squash}' optional: ${this.isOptional}}`;\n  }\n}\n"
  ]
}