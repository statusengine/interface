{
  "version": 3,
  "file": "pathUtils.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/path/pathUtils.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "import {\n  extend,\n  find,\n  pick,\n  omit,\n  tail,\n  mergeR,\n  values,\n  unnestR,\n  Predicate,\n  inArray,\n  arrayTuples,\n} from '../common/common';\nimport { prop, propEq, not } from '../common/hof';\n\nimport { RawParams } from '../params/interface';\nimport { TreeChanges } from '../transition/interface';\nimport { ViewConfig } from '../view/interface';\nimport { _ViewDeclaration } from '../state/interface';\n\nimport { StateObject } from '../state/stateObject';\nimport { TargetState } from '../state/targetState';\nimport { GetParamsFn, PathNode } from './pathNode';\nimport { ViewService } from '../view/view';\nimport { Param } from '../params/param';\nimport { StateRegistry } from '../state';\n\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\nexport class PathUtils {\n  /** Given a PathNode[], create an TargetState */\n  static makeTargetState(registry: StateRegistry, path: PathNode[]): TargetState {\n    const state = tail(path).state;\n    return new TargetState(registry, state, path.map(prop('paramValues')).reduce(mergeR, {}), {});\n  }\n\n  static buildPath(targetState: TargetState) {\n    const toParams = targetState.params();\n    return targetState.$state().path.map((state) => new PathNode(state).applyRawParams(toParams));\n  }\n\n  /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n  static buildToPath(fromPath: PathNode[], targetState: TargetState): PathNode[] {\n    const toPath: PathNode[] = PathUtils.buildPath(targetState);\n    if (targetState.options().inherit) {\n      return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n    }\n    return toPath;\n  }\n\n  /**\n   * Creates ViewConfig objects and adds to nodes.\n   *\n   * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n   */\n  static applyViewConfigs($view: ViewService, path: PathNode[], states: StateObject[]) {\n    // Only apply the viewConfigs to the nodes for the given states\n    path\n      .filter((node) => inArray(states, node.state))\n      .forEach((node) => {\n        const viewDecls: _ViewDeclaration[] = values(node.state.views || {});\n        const subPath = PathUtils.subPath(path, (n) => n === node);\n        const viewConfigs: ViewConfig[][] = viewDecls.map((view) => $view.createViewConfig(subPath, view));\n        node.views = viewConfigs.reduce(unnestR, []);\n      });\n  }\n\n  /**\n   * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n   *\n   * For a parameter in a node to be inherited from the from path:\n   * - The toPath's node must have a matching node in the fromPath (by state).\n   * - The parameter name must not be found in the toKeys parameter array.\n   *\n   * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n   * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n   * it is not inherited from the fromPath.\n   */\n  static inheritParams(fromPath: PathNode[], toPath: PathNode[], toKeys: string[] = []): PathNode[] {\n    function nodeParamVals(path: PathNode[], state: StateObject): RawParams {\n      const node: PathNode = find(path, propEq('state', state));\n      return extend({}, node && node.paramValues);\n    }\n\n    const noInherit = fromPath\n      .map((node) => node.paramSchema)\n      .reduce(unnestR, [])\n      .filter((param) => !param.inherit)\n      .map(prop('id'));\n\n    /**\n     * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n     * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n     */\n    function makeInheritedParamsNode(toNode: PathNode): PathNode {\n      // All param values for the node (may include default key/vals, when key was not found in toParams)\n      let toParamVals = extend({}, toNode && toNode.paramValues);\n      // limited to only those keys found in toParams\n      const incomingParamVals = pick(toParamVals, toKeys);\n      toParamVals = omit(toParamVals, toKeys);\n      const fromParamVals = omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n      // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n      const ownParamVals: RawParams = extend(toParamVals, fromParamVals, incomingParamVals);\n      return new PathNode(toNode.state).applyRawParams(ownParamVals);\n    }\n\n    // The param keys specified by the incoming toParams\n    return <PathNode[]>toPath.map(makeInheritedParamsNode);\n  }\n\n  static nonDynamicParams = (node: PathNode): Param[] =>\n    node.state.parameters({ inherit: false }).filter((param) => !param.dynamic);\n\n  /**\n   * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n   */\n  static treeChanges(fromPath: PathNode[], toPath: PathNode[], reloadState: StateObject): TreeChanges {\n    const max = Math.min(fromPath.length, toPath.length);\n    let keep = 0;\n\n    const nodesMatch = (node1: PathNode, node2: PathNode) => node1.equals(node2, PathUtils.nonDynamicParams);\n\n    while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n      keep++;\n    }\n\n    /** Given a retained node, return a new node which uses the to node's param values */\n    function applyToParams(retainedNode: PathNode, idx: number): PathNode {\n      const cloned = retainedNode.clone();\n      cloned.paramValues = toPath[idx].paramValues;\n      return cloned;\n    }\n\n    let from: PathNode[], retained: PathNode[], exiting: PathNode[], entering: PathNode[], to: PathNode[];\n\n    from = fromPath;\n    retained = from.slice(0, keep);\n    exiting = from.slice(keep);\n\n    // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n    const retainedWithToParams = retained.map(applyToParams);\n    entering = toPath.slice(keep);\n    to = retainedWithToParams.concat(entering);\n\n    return { from, to, retained, retainedWithToParams, exiting, entering };\n  }\n\n  /**\n   * Returns a new path which is: the subpath of the first path which matches the second path.\n   *\n   * The new path starts from root and contains any nodes that match the nodes in the second path.\n   * It stops before the first non-matching node.\n   *\n   * Nodes are compared using their state property and their parameter values.\n   * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.\n   *\n   * @param pathA the first path\n   * @param pathB the second path\n   * @param paramsFn a function which returns the parameters to consider when comparing\n   *\n   * @returns an array of PathNodes from the first path which match the nodes in the second path\n   */\n  static matching(pathA: PathNode[], pathB: PathNode[], paramsFn?: GetParamsFn): PathNode[] {\n    let done = false;\n    const tuples: PathNode[][] = arrayTuples(pathA, pathB);\n    return tuples.reduce((matching, [nodeA, nodeB]) => {\n      done = done || !nodeA.equals(nodeB, paramsFn);\n      return done ? matching : matching.concat(nodeA);\n    }, []);\n  }\n\n  /**\n   * Returns true if two paths are identical.\n   *\n   * @param pathA\n   * @param pathB\n   * @param paramsFn a function which returns the parameters to consider when comparing\n   * @returns true if the the states and parameter values for both paths are identical\n   */\n  static equals(pathA: PathNode[], pathB: PathNode[], paramsFn?: GetParamsFn): boolean {\n    return pathA.length === pathB.length && PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;\n  }\n\n  /**\n   * Return a subpath of a path, which stops at the first matching node\n   *\n   * Given an array of nodes, returns a subset of the array starting from the first node,\n   * stopping when the first node matches the predicate.\n   *\n   * @param path a path of [[PathNode]]s\n   * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n   * @returns a subpath up to the matching node, or undefined if no match is found\n   */\n  static subPath(path: PathNode[], predicate: Predicate<PathNode>): PathNode[] {\n    const node = find(path, predicate);\n    const elementIdx = path.indexOf(node);\n    return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n  }\n\n  /** Gets the raw parameter values from a path */\n  static paramValues = (path: PathNode[]) => path.reduce((acc, node) => extend(acc, node.paramValues), {});\n}\n"
  ]
}