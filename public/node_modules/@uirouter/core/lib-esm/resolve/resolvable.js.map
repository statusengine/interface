{
  "version": 3,
  "file": "resolvable.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/resolve/resolvable.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "import { extend, identity } from '../common/common';\nimport { services } from '../common/coreservices';\nimport { trace } from '../common/trace';\nimport { ResolvePolicy, ResolvableLiteral, PolicyAsync } from './interface';\n\nimport { ResolveContext } from './resolveContext';\nimport { stringify } from '../common/strings';\nimport { isFunction, isObject } from '../common/predicates';\nimport { Transition } from '../transition/transition';\nimport { StateObject } from '../state/stateObject';\nimport { PathNode } from '../path/pathNode';\nimport { isNullOrUndefined } from '../common/predicates';\n\n// TODO: explicitly make this user configurable\nexport let defaultResolvePolicy: ResolvePolicy = {\n  when: 'LAZY',\n  async: 'WAIT',\n};\n\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\nexport class Resolvable implements ResolvableLiteral {\n  token: any;\n  policy: ResolvePolicy;\n  resolveFn: Function;\n  deps: any[];\n\n  data: any;\n  resolved = false;\n  promise: Promise<any> = undefined;\n\n  static fromData = (token: any, data: any) => new Resolvable(token, () => data, null, null, data);\n\n  /** This constructor creates a Resolvable copy */\n  constructor(resolvable: Resolvable);\n\n  /** This constructor creates a new Resolvable from the plain old [[ResolvableLiteral]] javascript object */\n  constructor(resolvable: ResolvableLiteral);\n\n  /**\n   * This constructor creates a new `Resolvable`\n   *\n   * #### Example:\n   * ```js\n   * var resolvable1 = new Resolvable('mytoken', http => http.get('foo.json').toPromise(), [Http]);\n   *\n   * var resolvable2 = new Resolvable(UserService, dep => new UserService(dep.data), [SomeDependency]);\n   *\n   * var resolvable1Clone = new Resolvable(resolvable1);\n   * ```\n   *\n   * @param token The new resolvable's injection token, such as `\"userList\"` (a string) or `UserService` (a class).\n   *              When this token is used during injection, the resolved value will be injected.\n   * @param resolveFn The function that returns the resolved value, or a promise for the resolved value\n   * @param deps An array of dependencies, which will be injected into the `resolveFn`\n   * @param policy the [[ResolvePolicy]] defines when and how the Resolvable is processed\n   * @param data Pre-resolved data. If the resolve value is already known, it may be provided here.\n   */\n  constructor(token: any, resolveFn: Function, deps?: any[], policy?: ResolvePolicy, data?: any);\n  constructor(arg1: any, resolveFn?: Function, deps?: any[], policy?: ResolvePolicy, data?: any) {\n    if (arg1 instanceof Resolvable) {\n      extend(this, arg1);\n    } else if (isFunction(resolveFn)) {\n      if (isNullOrUndefined(arg1)) throw new Error('new Resolvable(): token argument is required');\n      if (!isFunction(resolveFn)) throw new Error('new Resolvable(): resolveFn argument must be a function');\n\n      this.token = arg1;\n      this.policy = policy;\n      this.resolveFn = resolveFn;\n      this.deps = deps || [];\n\n      this.data = data;\n      this.resolved = data !== undefined;\n      this.promise = this.resolved ? services.$q.when(this.data) : undefined;\n    } else if (isObject(arg1) && arg1.token && (arg1.hasOwnProperty('resolveFn') || arg1.hasOwnProperty('data'))) {\n      const literal = <ResolvableLiteral>arg1;\n      return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n    }\n  }\n\n  getPolicy(state: StateObject): ResolvePolicy {\n    const thisPolicy = this.policy || {};\n    const statePolicy = (state && state.resolvePolicy) || {};\n    return {\n      when: thisPolicy.when || statePolicy.when || defaultResolvePolicy.when,\n      async: thisPolicy.async || statePolicy.async || defaultResolvePolicy.async,\n    };\n  }\n\n  /**\n   * Asynchronously resolve this Resolvable's data\n   *\n   * Given a ResolveContext that this Resolvable is found in:\n   * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n   * and update the Resolvable's state\n   */\n  resolve(resolveContext: ResolveContext, trans?: Transition) {\n    const $q = services.$q;\n\n    // Gets all dependencies from ResolveContext and wait for them to be resolved\n    const getResolvableDependencies = () =>\n      $q.all(\n        resolveContext.getDependencies(this).map((resolvable) => resolvable.get(resolveContext, trans))\n      ) as Promise<any[]>;\n\n    // Invokes the resolve function passing the resolved dependencies as arguments\n    const invokeResolveFn = (resolvedDeps: any[]) => this.resolveFn.apply(null, resolvedDeps);\n    const node: PathNode = resolveContext.findNode(this);\n    const state: StateObject = node && node.state;\n\n    const asyncPolicy: PolicyAsync = this.getPolicy(state).async;\n    const customAsyncPolicy = isFunction(asyncPolicy) ? asyncPolicy : identity;\n\n    // After the final value has been resolved, update the state of the Resolvable\n    const applyResolvedValue = (resolvedValue: any) => {\n      this.data = resolvedValue;\n      this.resolved = true;\n      this.resolveFn = null;\n      trace.traceResolvableResolved(this, trans);\n      return this.data;\n    };\n\n    // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n    return (this.promise = $q\n      .when()\n      .then(getResolvableDependencies)\n      .then(invokeResolveFn)\n      .then(customAsyncPolicy)\n      .then(applyResolvedValue));\n  }\n\n  /**\n   * Gets a promise for this Resolvable's data.\n   *\n   * Fetches the data and returns a promise.\n   * Returns the existing promise if it has already been fetched once.\n   */\n  get(resolveContext: ResolveContext, trans?: Transition): Promise<any> {\n    return this.promise || this.resolve(resolveContext, trans);\n  }\n\n  toString() {\n    return `Resolvable(token: ${stringify(this.token)}, requires: [${this.deps.map(stringify)}])`;\n  }\n\n  clone(): Resolvable {\n    return new Resolvable(this);\n  }\n}\n"
  ]
}