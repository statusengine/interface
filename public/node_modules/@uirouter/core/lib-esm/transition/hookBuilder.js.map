{
  "version": 3,
  "file": "hookBuilder.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/transition/hookBuilder.ts"
  ],
  "names": [],
  "mappings": "AAAA,OAAO,EAAE,MAAM,EAAQ,eAAe,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,kBAAkB,CAAC;AACpF,OAAO,EAAE,OAAO,EAAE,MAAM,sBAAsB,CAAC;AAE/C,OAAO,EAML,mBAAmB,EACnB,mBAAmB,GACpB,MAAM,aAAa,CAAC;AAGrB,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAOlD;;;;;;;;;;;;GAYG;AACH;IACE,qBAAoB,UAAsB;QAAtB,eAAU,GAAV,UAAU,CAAY;IAAG,CAAC;IAE9C,wCAAkB,GAAlB,UAAmB,KAA0B;QAA7C,iBAOC;QANC,IAAM,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,iBAAiB,CAAC;QAC9D,OAAO,YAAY,CAAC,UAAU;aAC3B,UAAU,CAAC,KAAK,CAAC;aACjB,GAAG,CAAC,UAAC,IAAI,IAAK,OAAA,KAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAArB,CAAqB,CAAC;aACpC,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC;aACnB,MAAM,CAAC,QAAQ,CAAC,CAAC;IACtB,CAAC;IAED;;;;;;;;OAQG;IACH,gCAAU,GAAV,UAAW,QAA6B;QACtC,IAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;QACnC,IAAM,WAAW,GAAG,UAAU,CAAC,WAAW,EAAE,CAAC;QAE7C,+DAA+D;QAC/D,IAAM,aAAa,GAAG,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;QAC/E,IAAI,CAAC,aAAa;YAAE,OAAO,EAAE,CAAC;QAE9B,IAAM,eAAe,GAA0B;YAC7C,UAAU,EAAE,UAAU;YACtB,OAAO,EAAE,UAAU,CAAC,OAAO,EAAE,CAAC,OAAO;SACtC,CAAC;QAEF,IAAM,mBAAmB,GAAG,UAAC,IAAoB;YAC/C,kDAAkD;YAClD,IAAM,OAAO,GAAmB,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;YACtE,4EAA4E;YAC5E,IAAM,aAAa,GAAe,OAAO,CAAC,QAAQ,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;YAE3E,gCAAgC;YAChC,OAAO,aAAa,CAAC,GAAG,CAAC,UAAC,IAAI;gBAC5B,IAAM,QAAQ,GAAG,MAAM,CACrB;oBACE,IAAI,EAAE,IAAI,CAAC,IAAI;oBACf,SAAS,EAAE,EAAE,QAAQ,EAAE,QAAQ,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE;iBACtD,EACD,eAAe,CAChB,CAAC;gBAEF,IAAM,KAAK,GAAG,QAAQ,CAAC,iBAAiB,CAAC,KAAK,KAAK,mBAAmB,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;gBACtG,IAAM,cAAc,GAAG,IAAI,cAAc,CAAC,UAAU,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;gBAC7E,OAAkB,EAAE,IAAI,MAAA,EAAE,IAAI,MAAA,EAAE,cAAc,gBAAA,EAAE,CAAC;YACnD,CAAC,CAAC,CAAC;QACL,CAAC,CAAC;QAEF,OAAO,aAAa;aACjB,GAAG,CAAC,mBAAmB,CAAC;aACxB,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC;aACnB,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;aACrC,GAAG,CAAC,UAAC,KAAK,IAAK,OAAA,KAAK,CAAC,cAAc,EAApB,CAAoB,CAAC,CAAC;IAC1C,CAAC;IAED;;;;;;;;;;OAUG;IACI,sCAAgB,GAAvB,UACE,QAA6B,EAC7B,WAAwB,EACxB,UAAsB;QAEtB,IAAM,QAAQ,GAAG,QAAQ,CAAC,SAAS,KAAK,mBAAmB,CAAC,MAAM,CAAC;QAEnE,sCAAsC;QACtC,IAAM,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,iBAAiB,CAAC;QAC9D,IAAM,UAAU,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,EAAE,YAAY,CAAC,CAAC;QAE/E,OAAO,UAAU;aACd,GAAG,CAAC,UAAC,GAAkB,IAAK,OAAA,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,EAA3B,CAA2B,CAAC,CAAC,kCAAkC;aAC3F,MAAM,CAAC,eAAe,CAAC,OAAO,EAAE,yBAAuB,QAAQ,CAAC,IAAM,CAAC,CAAC,CAAC,eAAe;aACxF,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,uDAAuD;aAC3E,MAAM,CAAC,UAAC,IAAI,IAAK,OAAA,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,UAAU,CAAC,EAArC,CAAqC,CAAC,CAAC,CAAC,sCAAsC;IACpG,CAAC;IACH,kBAAC;AAAD,CAAC,AA3FD,IA2FC;;AAQD;;;;;;;;GAQG;AACH,SAAS,SAAS,CAAC,gBAAwB;IAAxB,iCAAA,EAAA,wBAAwB;IACzC,OAAO,SAAS,qBAAqB,CAAC,CAAY,EAAE,CAAY;QAC9D,IAAM,MAAM,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACzC,IAAM,UAAU,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;QAClF,OAAO,UAAU,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;IAC3E,CAAC,CAAC;AACJ,CAAC",
  "sourcesContent": [
    "import { extend, tail, assertPredicate, unnestR, identity } from '../common/common';\nimport { isArray } from '../common/predicates';\n\nimport {\n  TransitionOptions,\n  TransitionHookOptions,\n  IHookRegistry,\n  TreeChanges,\n  IMatchingNodes,\n  TransitionHookPhase,\n  TransitionHookScope,\n} from './interface';\n\nimport { Transition } from './transition';\nimport { TransitionHook } from './transitionHook';\nimport { StateObject } from '../state/stateObject';\nimport { PathNode } from '../path/pathNode';\nimport { TransitionService } from './transitionService';\nimport { TransitionEventType } from './transitionEventType';\nimport { RegisteredHook } from './hookRegistry';\n\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n */\nexport class HookBuilder {\n  constructor(private transition: Transition) {}\n\n  buildHooksForPhase(phase: TransitionHookPhase): TransitionHook[] {\n    const $transitions = this.transition.router.transitionService;\n    return $transitions._pluginapi\n      ._getEvents(phase)\n      .map((type) => this.buildHooks(type))\n      .reduce(unnestR, [])\n      .filter(identity);\n  }\n\n  /**\n   * Returns an array of newly built TransitionHook objects.\n   *\n   * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n   * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n   * - For each of the [[PathNode]]s, creates a TransitionHook\n   *\n   * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n   */\n  buildHooks(hookType: TransitionEventType): TransitionHook[] {\n    const transition = this.transition;\n    const treeChanges = transition.treeChanges();\n\n    // Find all the matching registered hooks for a given hook type\n    const matchingHooks = this.getMatchingHooks(hookType, treeChanges, transition);\n    if (!matchingHooks) return [];\n\n    const baseHookOptions = <TransitionHookOptions>{\n      transition: transition,\n      current: transition.options().current,\n    };\n\n    const makeTransitionHooks = (hook: RegisteredHook) => {\n      // Fetch the Nodes that caused this hook to match.\n      const matches: IMatchingNodes = hook.matches(treeChanges, transition);\n      // Select the PathNode[] that will be used as TransitionHook context objects\n      const matchingNodes: PathNode[] = matches[hookType.criteriaMatchPath.name];\n\n      // Return an array of HookTuples\n      return matchingNodes.map((node) => {\n        const _options = extend(\n          {\n            bind: hook.bind,\n            traceData: { hookType: hookType.name, context: node },\n          },\n          baseHookOptions\n        );\n\n        const state = hookType.criteriaMatchPath.scope === TransitionHookScope.STATE ? node.state.self : null;\n        const transitionHook = new TransitionHook(transition, state, hook, _options);\n        return <HookTuple>{ hook, node, transitionHook };\n      });\n    };\n\n    return matchingHooks\n      .map(makeTransitionHooks)\n      .reduce(unnestR, [])\n      .sort(tupleSort(hookType.reverseSort))\n      .map((tuple) => tuple.transitionHook);\n  }\n\n  /**\n   * Finds all RegisteredHooks from:\n   * - The Transition object instance hook registry\n   * - The TransitionService ($transitions) global hook registry\n   *\n   * which matched:\n   * - the eventType\n   * - the matchCriteria (to, from, exiting, retained, entering)\n   *\n   * @returns an array of matched [[RegisteredHook]]s\n   */\n  public getMatchingHooks(\n    hookType: TransitionEventType,\n    treeChanges: TreeChanges,\n    transition: Transition\n  ): RegisteredHook[] {\n    const isCreate = hookType.hookPhase === TransitionHookPhase.CREATE;\n\n    // Instance and Global hook registries\n    const $transitions = this.transition.router.transitionService;\n    const registries = isCreate ? [$transitions] : [this.transition, $transitions];\n\n    return registries\n      .map((reg: IHookRegistry) => reg.getHooks(hookType.name)) // Get named hooks from registries\n      .filter(assertPredicate(isArray, `broken event named: ${hookType.name}`)) // Sanity check\n      .reduce(unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n      .filter((hook) => hook.matches(treeChanges, transition)); // Only those satisfying matchCriteria\n  }\n}\n\ninterface HookTuple {\n  hook: RegisteredHook;\n  node: PathNode;\n  transitionHook: TransitionHook;\n}\n\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\nfunction tupleSort(reverseDepthSort = false) {\n  return function nodeDepthThenPriority(l: HookTuple, r: HookTuple): number {\n    const factor = reverseDepthSort ? -1 : 1;\n    const depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n    return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n  };\n}\n"
  ]
}