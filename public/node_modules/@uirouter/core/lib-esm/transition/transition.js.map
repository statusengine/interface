{
  "version": 3,
  "file": "transition.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/transition/transition.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "import { trace } from '../common/trace';\nimport { services } from '../common/coreservices';\nimport { stringify } from '../common/strings';\nimport { map, find, extend, mergeR, tail, omit, arrayTuples, unnestR, identity, anyTrueR } from '../common/common';\nimport { isObject, isUndefined } from '../common/predicates';\nimport { prop, propEq, val, not, is } from '../common/hof';\nimport { StateDeclaration, StateOrName } from '../state/interface';\nimport {\n  TransitionOptions,\n  TreeChanges,\n  IHookRegistry,\n  TransitionHookPhase,\n  RegisteredHooks,\n  HookRegOptions,\n  HookMatchCriteria,\n  TransitionStateHookFn,\n  TransitionHookFn,\n} from './interface'; // has or is using\nimport { TransitionHook } from './transitionHook';\nimport { matchState, makeEvent, RegisteredHook } from './hookRegistry';\nimport { HookBuilder } from './hookBuilder';\nimport { PathNode } from '../path/pathNode';\nimport { PathUtils } from '../path/pathUtils';\nimport { StateObject } from '../state/stateObject';\nimport { TargetState } from '../state/targetState';\nimport { Param } from '../params/param';\nimport { Resolvable } from '../resolve/resolvable';\nimport { ViewConfig } from '../view/interface';\nimport { ResolveContext } from '../resolve/resolveContext';\nimport { UIRouter } from '../router';\nimport { UIInjector } from '../interface';\nimport { RawParams } from '../params/interface';\nimport { ResolvableLiteral } from '../resolve/interface';\nimport { Rejection } from './rejectFactory';\nimport { applyPairs, flattenR, uniqR } from '../common';\n\n/** @internal */\nconst stateSelf: (_state: StateObject) => StateDeclaration = prop('self');\n\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\nexport class Transition implements IHookRegistry {\n  /** @internal */\n  static diToken = Transition;\n\n  /**\n   * A unique identifier for the transition.\n   *\n   * This is an auto incrementing integer, starting from `0`.\n   */\n  $id: number;\n\n  /**\n   * A reference to the [[UIRouter]] instance\n   *\n   * This reference can be used to access the router services, such as the [[StateService]]\n   */\n  router: UIRouter;\n\n  /** @internal */\n  private _deferred = services.$q.defer();\n  /**\n   * This promise is resolved or rejected based on the outcome of the Transition.\n   *\n   * When the transition is successful, the promise is resolved\n   * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n   */\n  promise: Promise<any> = this._deferred.promise;\n  /**\n   * A boolean which indicates if the transition was successful\n   *\n   * After a successful transition, this value is set to true.\n   * After an unsuccessful transition, this value is set to false.\n   *\n   * The value will be undefined if the transition is not complete\n   */\n  success: boolean;\n  /** @internal */\n  _aborted: boolean;\n  /** @internal */\n  private _error: Rejection;\n\n  /** @internal Holds the hook registration functions such as those passed to Transition.onStart() */\n  _registeredHooks: RegisteredHooks = {};\n\n  /** @internal */\n  private _options: TransitionOptions;\n  /** @internal */\n  private _treeChanges: TreeChanges;\n  /** @internal */\n  private _targetState: TargetState;\n  /** @internal */\n  private _hookBuilder = new HookBuilder(this);\n\n  /** @internal */\n  onBefore(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onStart(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onExit(criteria: HookMatchCriteria, callback: TransitionStateHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onRetain(criteria: HookMatchCriteria, callback: TransitionStateHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onEnter(criteria: HookMatchCriteria, callback: TransitionStateHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onFinish(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onSuccess(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onError(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n\n  /** @internal\n   * Creates the transition-level hook registration functions\n   * (which can then be used to register hooks)\n   */\n  private createTransitionHookRegFns() {\n    this.router.transitionService._pluginapi\n      ._getEvents()\n      .filter((type) => type.hookPhase !== TransitionHookPhase.CREATE)\n      .forEach((type) => makeEvent(this, this.router.transitionService, type));\n  }\n\n  /** @internal */\n  getHooks(hookName: string): RegisteredHook[] {\n    return this._registeredHooks[hookName];\n  }\n\n  /**\n   * Creates a new Transition object.\n   *\n   * If the target state is not valid, an error is thrown.\n   *\n   * @internal\n   *\n   * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n   *        encapsulates the \"from state\".\n   * @param targetState The target state and parameters being transitioned to (also, the transition options)\n   * @param router The [[UIRouter]] instance\n   * @internal\n   */\n  constructor(fromPath: PathNode[], targetState: TargetState, router: UIRouter) {\n    this.router = router;\n    this._targetState = targetState;\n\n    if (!targetState.valid()) {\n      throw new Error(targetState.error());\n    }\n\n    // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n    this._options = extend({ current: val(this) }, targetState.options());\n    this.$id = router.transitionService._transitionCount++;\n    const toPath = PathUtils.buildToPath(fromPath, targetState);\n    this._treeChanges = PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);\n    this.createTransitionHookRegFns();\n\n    const onCreateHooks = this._hookBuilder.buildHooksForPhase(TransitionHookPhase.CREATE);\n    TransitionHook.invokeHooks(onCreateHooks, () => null);\n\n    this.applyViewConfigs(router);\n  }\n\n  private applyViewConfigs(router: UIRouter) {\n    const enteringStates = this._treeChanges.entering.map((node) => node.state);\n    PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n  }\n\n  /**\n   * @internal\n   * @returns the internal from [State] object\n   */\n  $from() {\n    return tail(this._treeChanges.from).state;\n  }\n\n  /**\n   * @internal\n   * @returns the internal to [State] object\n   */\n  $to() {\n    return tail(this._treeChanges.to).state;\n  }\n\n  /**\n   * Returns the \"from state\"\n   *\n   * Returns the state that the transition is coming *from*.\n   *\n   * @returns The state declaration object for the Transition's (\"from state\").\n   */\n  from(): StateDeclaration {\n    return this.$from().self;\n  }\n\n  /**\n   * Returns the \"to state\"\n   *\n   * Returns the state that the transition is going *to*.\n   *\n   * @returns The state declaration object for the Transition's target state (\"to state\").\n   */\n  to(): StateDeclaration {\n    return this.$to().self;\n  }\n\n  /**\n   * Gets the Target State\n   *\n   * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n   *\n   * @returns the [[TargetState]] of this Transition\n   */\n  targetState() {\n    return this._targetState;\n  }\n\n  /**\n   * Determines whether two transitions are equivalent.\n   * @deprecated\n   */\n  is(compare: Transition | { to?: any; from?: any }): boolean {\n    if (compare instanceof Transition) {\n      // TODO: Also compare parameters\n      return this.is({ to: compare.$to().name, from: compare.$from().name });\n    }\n    return !(\n      (compare.to && !matchState(this.$to(), compare.to, this)) ||\n      (compare.from && !matchState(this.$from(), compare.from, this))\n    );\n  }\n\n  /**\n   * Gets transition parameter values\n   *\n   * Returns the parameter values for a transition as key/value pairs.\n   * This object is immutable.\n   *\n   * By default, returns the new parameter values (for the \"to state\").\n   *\n   * #### Example:\n   * ```js\n   * var toParams = transition.params();\n   * ```\n   *\n   * To return the previous parameter values,  supply `'from'` as the `pathname` argument.\n   *\n   * #### Example:\n   * ```js\n   * var fromParams = transition.params('from');\n   * ```\n   *\n   * @param pathname the name of the treeChanges path to get parameter values for:\n   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n   *\n   * @returns transition parameter values for the desired path.\n   */\n  params(pathname?: string): { [paramName: string]: any };\n  params<T>(pathname?: string): T;\n  params(pathname = 'to') {\n    return Object.freeze(this._treeChanges[pathname].map(prop('paramValues')).reduce(mergeR, {}));\n  }\n\n  /**\n   * Gets the new values of any parameters that changed during this transition.\n   *\n   * Returns any parameter values that have changed during a transition, as key/value pairs.\n   *\n   * - Any parameter values that have changed will be present on the returned object reflecting the new value.\n   * - Any parameters that *not* have changed will not be present on the returned object.\n   * - Any new parameters that weren't present in the \"from\" state, but are now present in the \"to\" state will be present on the returned object.\n   * - Any previous parameters that are no longer present (because the \"to\" state doesn't have them) will be included with a value of `undefined`.\n   *\n   * The returned object is immutable.\n   *\n   * #### Examples:\n   *\n   * Given:\n   * ```js\n   * var stateA = { name: 'stateA', url: '/stateA/:param1/param2' }\n   * var stateB = { name: 'stateB', url: '/stateB/:param3' }\n   * var stateC = { name: 'stateB.nest', url: '/nest/:param4' }\n   * ```\n   *\n   * #### Example 1\n   *\n   * From `/stateA/abc/def` to `/stateA/abc/xyz`\n   *\n   * ```js\n   * var changed = transition.paramsChanged()\n   * // changed is { param2: 'xyz' }\n   * ```\n   *\n   * The value of `param2` changed to `xyz`.\n   * The value of `param1` stayed the same so its value is not present.\n   *\n   * #### Example 2\n   *\n   * From `/stateA/abc/def` to `/stateB/123`\n   *\n   * ```js\n   * var changed = transition.paramsChanged()\n   * // changed is { param1: undefined, param2: undefined, param3: '123' }\n   * ```\n   *\n   * The value `param3` is present because it is a new param.\n   * Both `param1` and `param2` are no longer present so their value is undefined.\n   *\n   * #### Example 3\n   *\n   * From `/stateB/123` to `/stateB/123/nest/456`\n   *\n   * ```js\n   * var changed = transition.paramsChanged()\n   * // changed is { param4: '456' }\n   * ```\n   *\n   * The value `param4` is present because it is a new param.\n   * The value of `param3` did not change, so its value is not present.\n   *\n   * @returns an immutable object with changed parameter keys/values.\n   */\n  paramsChanged(): { [paramName: string]: any };\n  paramsChanged<T>(): T;\n  paramsChanged() {\n    const fromParams = this.params('from');\n    const toParams = this.params('to');\n\n    // All the parameters declared on both the \"to\" and \"from\" paths\n    const allParamDescriptors: Param[] = []\n      .concat(this._treeChanges.to)\n      .concat(this._treeChanges.from)\n      .map((pathNode) => pathNode.paramSchema)\n      .reduce(flattenR, [])\n      .reduce(uniqR, []);\n\n    const changedParamDescriptors = Param.changed(allParamDescriptors, fromParams, toParams);\n\n    return changedParamDescriptors.reduce((changedValues, descriptor) => {\n      changedValues[descriptor.id] = toParams[descriptor.id];\n      return changedValues;\n    }, {});\n  }\n\n  /**\n   * Creates a [[UIInjector]] Dependency Injector\n   *\n   * Returns a Dependency Injector for the Transition's target state (to state).\n   * The injector provides resolve values which the target state has access to.\n   *\n   * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n   *\n   * #### Example:\n   * ```js\n   * .onEnter({ entering: 'myState' }, trans => {\n   *   var myResolveValue = trans.injector().get('myResolve');\n   *   // Inject a global service from the global/native injector (if it exists)\n   *   var MyService = trans.injector().get('MyService');\n   * })\n   * ```\n   *\n   * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n   * You can use [[UIInjector.getAsync]] to get a promise for the data.\n   * #### Example:\n   * ```js\n   * .onBefore({}, trans => {\n   *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n   *     return myResolveValue !== 'ABORT';\n   *   });\n   * });\n   * ```\n   *\n   * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n   * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n   * #### Example:\n   * ```js\n   * .onEnter({ to: 'foo.bar' }, trans => {\n   *   // returns result of `foo` state's `myResolve` resolve\n   *   // even though `foo.bar` also has a `myResolve` resolve\n   *   var fooData = trans.injector('foo').get('myResolve');\n   * });\n   * ```\n   *\n   * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n   * The resolve data from the `from` path will be returned.\n   * #### Example:\n   * ```js\n   * .onExit({ exiting: 'foo.bar' }, trans => {\n   *   // Gets the resolve value of `myResolve` from the state being exited\n   *   var fooData = trans.injector(null, 'from').get('myResolve');\n   * });\n   * ```\n   *\n   *\n   * @param state Limits the resolves provided to only the resolves the provided state has access to.\n   * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n   *\n   * @returns a [[UIInjector]]\n   */\n  injector(state?: StateOrName, pathName = 'to'): UIInjector {\n    let path: PathNode[] = this._treeChanges[pathName];\n    if (state) path = PathUtils.subPath(path, (node) => node.state === state || node.state.name === state);\n    return new ResolveContext(path).injector();\n  }\n\n  /**\n   * Gets all available resolve tokens (keys)\n   *\n   * This method can be used in conjunction with [[injector]] to inspect the resolve values\n   * available to the Transition.\n   *\n   * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n   * in the Transition's [[TreeChanges.to]] path.\n   *\n   * #### Example:\n   * This example logs all resolve values\n   * ```js\n   * let tokens = trans.getResolveTokens();\n   * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n   * ```\n   *\n   * #### Example:\n   * This example creates promises for each resolve value.\n   * This triggers fetches of resolves (if any have not yet been fetched).\n   * When all promises have all settled, it logs the resolve values.\n   * ```js\n   * let tokens = trans.getResolveTokens();\n   * let promise = tokens.map(token => trans.injector().getAsync(token));\n   * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n   * ```\n   *\n   * Note: Angular 1 users whould use `$q.all()`\n   *\n   * @param pathname resolve context's path name (e.g., `to` or `from`)\n   *\n   * @returns an array of resolve tokens (keys)\n   */\n  getResolveTokens(pathname = 'to'): any[] {\n    return new ResolveContext(this._treeChanges[pathname]).getTokens();\n  }\n\n  /**\n   * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n   *\n   * Allows a transition hook to dynamically add a Resolvable to this Transition.\n   *\n   * Use the [[Transition.injector]] to retrieve the resolved data in subsequent hooks ([[UIInjector.get]]).\n   *\n   * If a `state` argument is provided, the Resolvable is processed when that state is being entered.\n   * If no `state` is provided then the root state is used.\n   * If the given `state` has already been entered, the Resolvable is processed when any child state is entered.\n   * If no child states will be entered, the Resolvable is processed during the `onFinish` phase of the Transition.\n   *\n   * The `state` argument also scopes the resolved data.\n   * The resolved data is available from the injector for that `state` and any children states.\n   *\n   * #### Example:\n   * ```js\n   * transitionService.onBefore({}, transition => {\n   *   transition.addResolvable({\n   *     token: 'myResolve',\n   *     deps: ['MyService'],\n   *     resolveFn: myService => myService.getData()\n   *   });\n   * });\n   * ```\n   *\n   * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n   * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n   */\n  addResolvable(resolvable: Resolvable | ResolvableLiteral, state: StateOrName = ''): void {\n    resolvable = is(Resolvable)(resolvable) ? resolvable : new Resolvable(resolvable);\n\n    const stateName: string = typeof state === 'string' ? state : state.name;\n    const topath = this._treeChanges.to;\n    const targetNode = find(topath, (node) => node.state.name === stateName);\n    const resolveContext: ResolveContext = new ResolveContext(topath);\n    resolveContext.addResolvables([resolvable as Resolvable], targetNode.state);\n  }\n\n  /**\n   * Gets the transition from which this transition was redirected.\n   *\n   * If the current transition is a redirect, this method returns the transition that was redirected.\n   *\n   * #### Example:\n   * ```js\n   * let transitionA = $state.go('A').transition\n   * transitionA.onStart({}, () => $state.target('B'));\n   * $transitions.onSuccess({ to: 'B' }, (trans) => {\n   *   trans.to().name === 'B'; // true\n   *   trans.redirectedFrom() === transitionA; // true\n   * });\n   * ```\n   *\n   * @returns The previous Transition, or null if this Transition is not the result of a redirection\n   */\n  redirectedFrom(): Transition {\n    return this._options.redirectedFrom || null;\n  }\n\n  /**\n   * Gets the original transition in a redirect chain\n   *\n   * A transition might belong to a long chain of multiple redirects.\n   * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n   *\n   * #### Example:\n   * ```js\n   * // states\n   * registry.register({ name: 'A', redirectTo: 'B' });\n   * registry.register({ name: 'B', redirectTo: 'C' });\n   * registry.register({ name: 'C', redirectTo: 'D' });\n   * registry.register({ name: 'D' });\n   *\n   * let transitionA = $state.go('A').transition\n   *\n   * $transitions.onSuccess({ to: 'D' }, (trans) => {\n   *   trans.to().name === 'D'; // true\n   *   trans.redirectedFrom().to().name === 'C'; // true\n   *   trans.originalTransition() === transitionA; // true\n   *   trans.originalTransition().to().name === 'A'; // true\n   * });\n   * ```\n   *\n   * @returns The original Transition that started a redirect chain\n   */\n  originalTransition(): Transition {\n    const rf = this.redirectedFrom();\n    return (rf && rf.originalTransition()) || this;\n  }\n\n  /**\n   * Get the transition options\n   *\n   * @returns the options for this Transition.\n   */\n  options(): TransitionOptions {\n    return this._options;\n  }\n\n  /**\n   * Gets the states being entered.\n   *\n   * @returns an array of states that will be entered during this transition.\n   */\n  entering(): StateDeclaration[] {\n    return map(this._treeChanges.entering, prop('state')).map(stateSelf);\n  }\n\n  /**\n   * Gets the states being exited.\n   *\n   * @returns an array of states that will be exited during this transition.\n   */\n  exiting(): StateDeclaration[] {\n    return map(this._treeChanges.exiting, prop('state')).map(stateSelf).reverse();\n  }\n\n  /**\n   * Gets the states being retained.\n   *\n   * @returns an array of states that are already entered from a previous Transition, that will not be\n   *    exited during this Transition\n   */\n  retained(): StateDeclaration[] {\n    return map(this._treeChanges.retained, prop('state')).map(stateSelf);\n  }\n\n  /**\n   * Get the [[ViewConfig]]s associated with this Transition\n   *\n   * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n   * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n   *\n   * @param pathname the name of the path to fetch views for:\n   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n   * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n   *\n   * @returns a list of ViewConfig objects for the given path.\n   */\n  views(pathname = 'entering', state?: StateObject): ViewConfig[] {\n    let path = this._treeChanges[pathname];\n    path = !state ? path : path.filter(propEq('state', state));\n    return path.map(prop('views')).filter(identity).reduce(unnestR, []);\n  }\n\n  /**\n   * Return the transition's tree changes\n   *\n   * A transition goes from one state/parameters to another state/parameters.\n   * During a transition, states are entered and/or exited.\n   *\n   * This function returns various branches (paths) which represent the changes to the\n   * active state tree that are caused by the transition.\n   *\n   * @param pathname The name of the tree changes path to get:\n   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n   */\n  treeChanges(pathname: string): PathNode[];\n  treeChanges(): TreeChanges;\n  treeChanges(pathname?: string) {\n    return pathname ? this._treeChanges[pathname] : this._treeChanges;\n  }\n\n  /**\n   * Creates a new transition that is a redirection of the current one.\n   *\n   * This transition can be returned from a [[TransitionService]] hook to\n   * redirect a transition to a new state and/or set of parameters.\n   *\n   * @internal\n   *\n   * @returns Returns a new [[Transition]] instance.\n   */\n  redirect(targetState: TargetState): Transition {\n    let redirects = 1,\n      trans: Transition = this;\n    // tslint:disable-next-line:no-conditional-assignment\n    while ((trans = trans.redirectedFrom()) != null) {\n      if (++redirects > 20) throw new Error(`Too many consecutive Transition redirects (20+)`);\n    }\n\n    const redirectOpts: TransitionOptions = { redirectedFrom: this, source: 'redirect' };\n    // If the original transition was caused by URL sync, then use { location: 'replace' }\n    // on the new transition (unless the target state explicitly specifies location: false).\n    // This causes the original url to be replaced with the url for the redirect target\n    // so the original url disappears from the browser history.\n    if (this.options().source === 'url' && targetState.options().location !== false) {\n      redirectOpts.location = 'replace';\n    }\n\n    const newOptions = extend({}, this.options(), targetState.options(), redirectOpts);\n    targetState = targetState.withOptions(newOptions, true);\n\n    const newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n    const originalEnteringNodes = this._treeChanges.entering;\n    const redirectEnteringNodes = newTransition._treeChanges.entering;\n\n    // --- Re-use resolve data from original transition ---\n    // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n    // (because of the redirect), the resolves fetched by the original transition are still valid in the\n    // redirected transition.\n    //\n    // This allows you to define a redirect on a parent state which depends on an async resolve value.\n    // You can wait for the resolve, then redirect to a child state based on the result.\n    // The redirected transition does not have to re-fetch the resolve.\n    // ---------------------------------------------------------\n\n    const nodeIsReloading = (reloadState: StateObject) => (node: PathNode) => {\n      return reloadState && node.state.includes[reloadState.name];\n    };\n\n    // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n    const matchingEnteringNodes: PathNode[] = PathUtils.matching(\n      redirectEnteringNodes,\n      originalEnteringNodes,\n      PathUtils.nonDynamicParams\n    ).filter(not(nodeIsReloading(targetState.options().reloadState)));\n\n    // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n    matchingEnteringNodes.forEach((node, idx) => {\n      node.resolvables = originalEnteringNodes[idx].resolvables;\n    });\n\n    return newTransition;\n  }\n\n  /** @internal If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n  private _changedParams(): Param[] {\n    const tc = this._treeChanges;\n\n    /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n    // If user explicitly wants a reload\n    if (this._options.reload) return undefined;\n    // If any states are exiting or entering\n    if (tc.exiting.length || tc.entering.length) return undefined;\n    // If to/from path lengths differ\n    if (tc.to.length !== tc.from.length) return undefined;\n    // If the to/from paths are different\n    const pathsDiffer: boolean = arrayTuples(tc.to, tc.from)\n      .map((tuple) => tuple[0].state !== tuple[1].state)\n      .reduce(anyTrueR, false);\n    if (pathsDiffer) return undefined;\n\n    // Find any parameter values that differ\n    const nodeSchemas: Param[][] = tc.to.map((node: PathNode) => node.paramSchema);\n    const [toValues, fromValues] = [tc.to, tc.from].map((path) => path.map((x) => x.paramValues));\n    const tuples = arrayTuples(nodeSchemas, toValues, fromValues);\n\n    return tuples.map(([schema, toVals, fromVals]) => Param.changed(schema, toVals, fromVals)).reduce(unnestR, []);\n  }\n\n  /**\n   * Returns true if the transition is dynamic.\n   *\n   * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n   *\n   * @returns true if the Transition is dynamic\n   */\n  dynamic(): boolean {\n    const changes = this._changedParams();\n    return !changes ? false : changes.map((x) => x.dynamic).reduce(anyTrueR, false);\n  }\n\n  /**\n   * Returns true if the transition is ignored.\n   *\n   * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n   *\n   * @returns true if the Transition is ignored.\n   */\n  ignored(): boolean {\n    return !!this._ignoredReason();\n  }\n\n  /** @internal */\n  _ignoredReason(): 'SameAsCurrent' | 'SameAsPending' | undefined {\n    const pending = this.router.globals.transition;\n    const reloadState = this._options.reloadState;\n\n    const same = (pathA, pathB) => {\n      if (pathA.length !== pathB.length) return false;\n      const matching = PathUtils.matching(pathA, pathB);\n      return pathA.length === matching.filter((node) => !reloadState || !node.state.includes[reloadState.name]).length;\n    };\n\n    const newTC = this.treeChanges();\n    const pendTC = pending && pending.treeChanges();\n\n    if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting)) return 'SameAsPending';\n    if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to)) return 'SameAsCurrent';\n  }\n\n  /**\n   * Runs the transition\n   *\n   * This method is generally called from the [[StateService.transitionTo]]\n   *\n   * @internal\n   *\n   * @returns a promise for a successful transition.\n   */\n  run(): Promise<any> {\n    const runAllHooks = TransitionHook.runAllHooks;\n\n    // Gets transition hooks array for the given phase\n    const getHooksFor = (phase: TransitionHookPhase) => this._hookBuilder.buildHooksForPhase(phase);\n\n    // When the chain is complete, then resolve or reject the deferred\n    const transitionSuccess = () => {\n      trace.traceSuccess(this.$to(), this);\n      this.success = true;\n      this._deferred.resolve(this.to());\n      runAllHooks(getHooksFor(TransitionHookPhase.SUCCESS));\n    };\n\n    const transitionError = (reason: Rejection) => {\n      trace.traceError(reason, this);\n      this.success = false;\n      this._deferred.reject(reason);\n      this._error = reason;\n      runAllHooks(getHooksFor(TransitionHookPhase.ERROR));\n    };\n\n    const runTransition = () => {\n      // Wait to build the RUN hook chain until the BEFORE hooks are done\n      // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.\n      const allRunHooks = getHooksFor(TransitionHookPhase.RUN);\n      const done = () => services.$q.when(undefined);\n      return TransitionHook.invokeHooks(allRunHooks, done);\n    };\n\n    const startTransition = () => {\n      const globals = this.router.globals;\n\n      globals.lastStartedTransitionId = this.$id;\n      globals.transition = this;\n      globals.transitionHistory.enqueue(this);\n\n      trace.traceTransitionStart(this);\n\n      return services.$q.when(undefined);\n    };\n\n    const allBeforeHooks = getHooksFor(TransitionHookPhase.BEFORE);\n    TransitionHook.invokeHooks(allBeforeHooks, startTransition)\n      .then(runTransition)\n      .then(transitionSuccess, transitionError);\n\n    return this.promise;\n  }\n\n  /** Checks if this transition is currently active/running. */\n  isActive = () => this.router.globals.transition === this;\n\n  /**\n   * Checks if the Transition is valid\n   *\n   * @returns true if the Transition is valid\n   */\n  valid() {\n    return !this.error() || this.success !== undefined;\n  }\n\n  /**\n   * Aborts this transition\n   *\n   * Imperative API to abort a Transition.\n   * This only applies to Transitions that are not yet complete.\n   */\n  abort() {\n    // Do not set flag if the transition is already complete\n    if (isUndefined(this.success)) {\n      this._aborted = true;\n    }\n  }\n\n  /**\n   * The Transition error reason.\n   *\n   * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n   * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n   *\n   * @returns a transition rejection explaining why the transition is invalid, or the reason the transition failed.\n   */\n  error(): Rejection {\n    const state: StateObject = this.$to();\n\n    if (state.self.abstract) {\n      return Rejection.invalid(`Cannot transition to abstract state '${state.name}'`);\n    }\n\n    const paramDefs = state.parameters();\n    const values = this.params();\n    const invalidParams = paramDefs.filter((param) => !param.validates(values[param.id]));\n\n    if (invalidParams.length) {\n      const invalidValues = invalidParams.map((param) => `[${param.id}:${stringify(values[param.id])}]`).join(', ');\n      const detail = `The following parameter values are not valid for state '${state.name}': ${invalidValues}`;\n      return Rejection.invalid(detail);\n    }\n\n    if (this.success === false) return this._error;\n  }\n\n  /**\n   * A string representation of the Transition\n   *\n   * @returns A string representation of the Transition\n   */\n  toString() {\n    const fromStateOrName = this.from();\n    const toStateOrName = this.to();\n\n    const avoidEmptyHash = (params: RawParams) =>\n      params['#'] !== null && params['#'] !== undefined ? params : omit(params, ['#']);\n\n    // (X) means the to state is invalid.\n    const id = this.$id,\n      from = isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName,\n      fromParams = stringify(avoidEmptyHash(this._treeChanges.from.map(prop('paramValues')).reduce(mergeR, {}))),\n      toValid = this.valid() ? '' : '(X) ',\n      to = isObject(toStateOrName) ? toStateOrName.name : toStateOrName,\n      toParams = stringify(avoidEmptyHash(this.params()));\n\n    return `Transition#${id}( '${from}'${fromParams} -> ${toValid}'${to}'${toParams} )`;\n  }\n}\n"
  ]
}