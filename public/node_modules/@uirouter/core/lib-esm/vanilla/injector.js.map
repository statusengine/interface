{
  "version": 3,
  "file": "injector.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/vanilla/injector.ts"
  ],
  "names": [],
  "mappings": "AAAA,OAAO,EACL,MAAM,EACN,eAAe,EACf,UAAU,EACV,OAAO,EACP,YAAY,GAGb,MAAM,iBAAiB,CAAC;AAEzB,iCAAiC;AACjC,IAAM,OAAO,GAAG,EAAE,CAAC;AACnB,IAAM,cAAc,GAAG,kCAAkC,CAAC;AAC1D,IAAM,cAAc,GAAG,YAAY,CAAC;AAEpC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8CG;AACH,MAAM,CAAC,IAAM,SAAS,GAAG;IACvB,qDAAqD;IACrD,GAAG,EAAE,UAAC,IAAI,IAAK,OAAA,OAAO,CAAC,IAAI,CAAC,EAAb,CAAa;IAE5B,iEAAiE;IACjE,GAAG,EAAE,UAAC,IAAI,IAAK,OAAA,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,EAA3B,CAA2B;IAE1C;;;;;;OAMG;IACH,MAAM,EAAE,UAAC,EAAe,EAAE,OAAQ,EAAE,MAAO;QACzC,IAAM,GAAG,GAAG,MAAM,CAAC,EAAE,EAAE,OAAO,EAAE,MAAM,IAAI,EAAE,CAAC,CAAC;QAC9C,IAAM,MAAM,GAAG,SAAS,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;QACtC,IAAM,WAAW,GAAG,eAAe,CACjC,UAAC,GAAW,IAAK,OAAA,GAAG,CAAC,cAAc,CAAC,GAAG,CAAC,EAAvB,CAAuB,EACxC,UAAC,GAAG,IAAK,OAAA,gCAA8B,GAAG,MAAG,EAApC,CAAoC,CAC9C,CAAC;QACF,IAAM,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,GAAG,CAAC,CAAC,CAAC,EAAN,CAAM,CAAC,CAAC;QAC3D,IAAI,UAAU,CAAC,EAAE,CAAC;YAAE,OAAO,EAAE,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;;YAC9C,OAAQ,EAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IAC9D,CAAC;IAED;;;;;OAKG;IACH,QAAQ,EAAE,UAAC,EAAe;QACxB,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC;YAAE,MAAM,IAAI,KAAK,CAAC,iCAA+B,EAAI,CAAC,CAAC;QAC5E,IAAI,EAAE,IAAK,EAAU,CAAC,OAAO;YAAE,OAAQ,EAAU,CAAC,OAAO,CAAC;QAC1D,IAAI,OAAO,CAAC,EAAE,CAAC;YAAE,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACxC,IAAM,KAAK,GAAG,EAAE,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC,CAAC;QACxD,IAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;QAC7F,OAAO,MAAM,IAAI,EAAE,CAAC;IACtB,CAAC;CACe,CAAC",
  "sourcesContent": [
    "import {\n  extend,\n  assertPredicate,\n  isFunction,\n  isArray,\n  isInjectable,\n  $InjectorLike,\n  IInjectable,\n} from '../common/index';\n\n// globally available injectables\nconst globals = {};\nconst STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/gm;\nconst ARGUMENT_NAMES = /([^\\s,]+)/g;\n\n/**\n * A basic angular1-like injector api\n *\n * This object implements four methods similar to the\n * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This object provides a naive implementation of a globally scoped dependency injection system.\n * It supports the following DI approaches:\n *\n * ### Function parameter names\n *\n * A function's `.toString()` is called, and the parameter names are parsed.\n * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n *\n * ```js\n * function injectedFunction(FooService, BarService) {\n *   // FooService and BarService are injected\n * }\n * ```\n *\n * ### Function annotation\n *\n * A function may be annotated with an array of dependency names as the `$inject` property.\n *\n * ```js\n * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n * function injectedFunction(fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }\n * ```\n *\n * ### Array notation\n *\n * An array provides the names of the dependencies to inject (as strings).\n * The function is the last element of the array.\n *\n * ```js\n * [ 'FooService', 'BarService', function (fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }]\n * ```\n *\n * @type {$InjectorLike}\n */\nexport const $injector = {\n  /** Gets an object from DI based on a string token */\n  get: (name) => globals[name],\n\n  /** Returns true if an object named `name` exists in global DI */\n  has: (name) => $injector.get(name) != null,\n\n  /**\n   * Injects a function\n   *\n   * @param fn the function to inject\n   * @param context the function's `this` binding\n   * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n   */\n  invoke: (fn: IInjectable, context?, locals?) => {\n    const all = extend({}, globals, locals || {});\n    const params = $injector.annotate(fn);\n    const ensureExist = assertPredicate(\n      (key: string) => all.hasOwnProperty(key),\n      (key) => `DI can't find injectable: '${key}'`\n    );\n    const args = params.filter(ensureExist).map((x) => all[x]);\n    if (isFunction(fn)) return fn.apply(context, args);\n    else return (fn as any[]).slice(-1)[0].apply(context, args);\n  },\n\n  /**\n   * Returns a function's dependencies\n   *\n   * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n   * @return an array of `string`s\n   */\n  annotate: (fn: IInjectable): any[] => {\n    if (!isInjectable(fn)) throw new Error(`Not an injectable function: ${fn}`);\n    if (fn && (fn as any).$inject) return (fn as any).$inject;\n    if (isArray(fn)) return fn.slice(0, -1);\n    const fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n    const result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n    return result || [];\n  },\n} as $InjectorLike;\n"
  ]
}