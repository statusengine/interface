{
  "version": 3,
  "file": "views.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/hooks/views.ts"
  ],
  "names": [],
  "mappings": ";;;AAAA,2CAAwC;AACxC,uDAAkD;AAOlD;;;;;;;GAOG;AACH,IAAM,iBAAiB,GAAqB,UAAC,UAAsB;IACjE,IAAM,EAAE,GAAG,uBAAQ,CAAC,EAAE,CAAC;IACvB,IAAM,aAAa,GAAG,UAAU,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;IACnD,IAAI,CAAC,aAAa,CAAC,MAAM;QAAE,OAAO;IAClC,OAAO,EAAE,CAAC,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,UAAC,IAAI,IAAK,OAAA,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,EAApB,CAAoB,CAAC,CAAC,CAAC,IAAI,CAAC,aAAI,CAAC,CAAC;AAC9E,CAAC,CAAC;AAEW,QAAA,yBAAyB,GAAG,UAAC,iBAAoC;IAC5E,OAAA,iBAAiB,CAAC,QAAQ,CAAC,EAAE,EAAE,iBAAiB,CAAC;AAAjD,CAAiD,CAAC;AAEpD;;;;;;;;;GASG;AACH,IAAM,aAAa,GAAqB,UAAC,UAAsB;IAC7D,IAAM,aAAa,GAAG,UAAU,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;IACnD,IAAM,YAAY,GAAG,UAAU,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IACjD,IAAI,CAAC,aAAa,CAAC,MAAM,IAAI,CAAC,YAAY,CAAC,MAAM;QAAE,OAAO;IAE1D,IAAM,KAAK,GAAgB,UAAU,CAAC,MAAM,CAAC,WAAW,CAAC;IAEzD,YAAY,CAAC,OAAO,CAAC,UAAC,EAAc,IAAK,OAAA,KAAK,CAAC,oBAAoB,CAAC,EAAE,CAAC,EAA9B,CAA8B,CAAC,CAAC;IACzE,aAAa,CAAC,OAAO,CAAC,UAAC,EAAc,IAAK,OAAA,KAAK,CAAC,kBAAkB,CAAC,EAAE,CAAC,EAA5B,CAA4B,CAAC,CAAC;IAExE,KAAK,CAAC,IAAI,EAAE,CAAC;AACf,CAAC,CAAC;AAEW,QAAA,qBAAqB,GAAG,UAAC,iBAAoC;IACxE,OAAA,iBAAiB,CAAC,SAAS,CAAC,EAAE,EAAE,aAAa,CAAC;AAA9C,CAA8C,CAAC",
  "sourcesContent": [
    "import { noop } from '../common/common';\nimport { services } from '../common/coreservices';\nimport { Transition } from '../transition/transition';\nimport { ViewService } from '../view/view';\nimport { ViewConfig } from '../view/interface';\nimport { TransitionHookFn } from '../transition/interface';\nimport { TransitionService } from '../transition/transitionService';\n\n/**\n * A [[TransitionHookFn]] which waits for the views to load\n *\n * Registered using `transitionService.onStart({}, loadEnteringViews);`\n *\n * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n * In angular 1, this includes loading the templates.\n */\nconst loadEnteringViews: TransitionHookFn = (transition: Transition) => {\n  const $q = services.$q;\n  const enteringViews = transition.views('entering');\n  if (!enteringViews.length) return;\n  return $q.all(enteringViews.map((view) => $q.when(view.load()))).then(noop);\n};\n\nexport const registerLoadEnteringViews = (transitionService: TransitionService) =>\n  transitionService.onFinish({}, loadEnteringViews);\n\n/**\n * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n *\n * Registered using `transitionService.onSuccess({}, activateViews);`\n *\n * After a transition is complete, this hook deactivates the old views from the previous state,\n * and activates the new views from the destination state.\n *\n * See [[ViewService]]\n */\nconst activateViews: TransitionHookFn = (transition: Transition) => {\n  const enteringViews = transition.views('entering');\n  const exitingViews = transition.views('exiting');\n  if (!enteringViews.length && !exitingViews.length) return;\n\n  const $view: ViewService = transition.router.viewService;\n\n  exitingViews.forEach((vc: ViewConfig) => $view.deactivateViewConfig(vc));\n  enteringViews.forEach((vc: ViewConfig) => $view.activateViewConfig(vc));\n\n  $view.sync();\n};\n\nexport const registerActivateViews = (transitionService: TransitionService) =>\n  transitionService.onSuccess({}, activateViews);\n"
  ]
}