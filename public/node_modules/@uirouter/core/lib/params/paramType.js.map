{
  "version": 3,
  "file": "paramType.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/params/paramType.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "import { extend, filter, map } from '../common/common';\nimport { isArray, isDefined } from '../common/predicates';\nimport { ParamTypeDefinition } from './interface';\n\n/**\n * An internal class which implements [[ParamTypeDefinition]].\n *\n * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n * When a param type definition is registered, an instance of this class is created internally.\n *\n * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n *\n * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n *\n * #### Example:\n * ```js\n * var paramTypeDef = {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n *\n * var paramType = new ParamType(paramTypeDef);\n * ```\n */\nexport class ParamType implements ParamTypeDefinition {\n  /** @inheritdoc */\n  pattern: RegExp = /.*/;\n  /** The name/id of the parameter type */\n  name: string;\n  /** @inheritdoc */\n  raw: boolean;\n  /** @inheritdoc */\n  dynamic: boolean;\n  /** @inheritdoc */\n  inherit = true;\n\n  /**\n   * @param def  A configuration object which contains the custom type definition.  The object's\n   *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n   * @returns a new ParamType object\n   */\n  constructor(def: ParamTypeDefinition) {\n    extend(this, def);\n  }\n\n  // consider these four methods to be \"abstract methods\" that should be overridden\n  /** @inheritdoc */\n  is(val: any, key?: string): boolean {\n    return true;\n  }\n  /** @inheritdoc */\n  encode(val: any, key?: string): string | string[] {\n    return val;\n  }\n  /** @inheritdoc */\n  decode(val: string, key?: string): any {\n    return val;\n  }\n  /** @inheritdoc */\n  equals(a: any, b: any): boolean {\n    // tslint:disable-next-line:triple-equals\n    return a == b;\n  }\n\n  $subPattern() {\n    const sub = this.pattern.toString();\n    return sub.substr(1, sub.length - 2);\n  }\n\n  toString() {\n    return `{ParamType:${this.name}}`;\n  }\n\n  /** Given an encoded string, or a decoded object, returns a decoded object */\n  $normalize(val: any) {\n    return this.is(val) ? val : this.decode(val);\n  }\n\n  /**\n   * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n   * e.g.:\n   * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n   * - url: \"/path?queryParam=1&queryParam=2\n   * - $stateParams.queryParam will be [1, 2]\n   * if `mode` is \"auto\", then\n   * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n   * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n   */\n  $asArray(mode: boolean | 'auto', isSearch: boolean) {\n    if (!mode) return this;\n    if (mode === 'auto' && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n    return new (<any>ArrayType)(this, mode);\n  }\n}\n\n/** Wraps up a `ParamType` object to handle array values. */\nfunction ArrayType(type: ParamType, mode: boolean | 'auto') {\n  // Wrap non-array value as array\n  function arrayWrap(val: any): any[] {\n    return isArray(val) ? val : isDefined(val) ? [val] : [];\n  }\n\n  // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n  function arrayUnwrap(val: any) {\n    switch (val.length) {\n      case 0:\n        return undefined;\n      case 1:\n        return mode === 'auto' ? val[0] : val;\n      default:\n        return val;\n    }\n  }\n\n  // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n  function arrayHandler(callback: (x: any) => any, allTruthyMode?: boolean) {\n    return function handleArray(val: any) {\n      if (isArray(val) && val.length === 0) return val;\n      const arr = arrayWrap(val);\n      const result = map(arr, callback);\n      return allTruthyMode === true ? filter(result, (x) => !x).length === 0 : arrayUnwrap(result);\n    };\n  }\n\n  // Wraps type (.equals) functions to operate on each value of an array\n  function arrayEqualsHandler(callback: (l: any, r: any) => boolean) {\n    return function handleArray(val1: any, val2: any) {\n      const left = arrayWrap(val1),\n        right = arrayWrap(val2);\n      if (left.length !== right.length) return false;\n      for (let i = 0; i < left.length; i++) {\n        if (!callback(left[i], right[i])) return false;\n      }\n      return true;\n    };\n  }\n\n  ['encode', 'decode', 'equals', '$normalize'].forEach((name) => {\n    const paramTypeFn = type[name].bind(type);\n    const wrapperFn: Function = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n    this[name] = wrapperFn(paramTypeFn);\n  });\n\n  extend(this, {\n    dynamic: type.dynamic,\n    name: type.name,\n    pattern: type.pattern,\n    inherit: type.inherit,\n    raw: type.raw,\n    is: arrayHandler(type.is.bind(type), true),\n    $arrayMode: mode,\n  });\n}\n"
  ]
}