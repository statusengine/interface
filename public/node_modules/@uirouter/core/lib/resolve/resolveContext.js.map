{
  "version": 3,
  "file": "resolveContext.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/resolve/resolveContext.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "import { find, tail, uniqR, unnestR, inArray } from '../common/common';\nimport { propEq, not } from '../common/hof';\nimport { trace } from '../common/trace';\nimport { services, $InjectorLike } from '../common/coreservices';\nimport { resolvePolicies, PolicyWhen, ResolvePolicy } from './interface';\nimport { PathNode } from '../path/pathNode';\nimport { Resolvable } from './resolvable';\nimport { StateObject } from '../state/stateObject';\nimport { PathUtils } from '../path/pathUtils';\nimport { stringify } from '../common/strings';\nimport { Transition } from '../transition/transition';\nimport { UIInjector } from '../interface';\nimport { isUndefined } from '../common';\n\nconst whens = resolvePolicies.when;\nconst ALL_WHENS = [whens.EAGER, whens.LAZY];\nconst EAGER_WHENS = [whens.EAGER];\n\n// tslint:disable-next-line:no-inferrable-types\nexport const NATIVE_INJECTOR_TOKEN: string = 'Native Injector';\n\n/**\n * Encapsulates Dependency Injection for a path of nodes\n *\n * UI-Router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\nexport class ResolveContext {\n  _injector: UIInjector;\n\n  constructor(private _path: PathNode[]) {}\n\n  /** Gets all the tokens found in the resolve context, de-duplicated */\n  getTokens(): any[] {\n    return this._path.reduce((acc, node) => acc.concat(node.resolvables.map((r) => r.token)), []).reduce(uniqR, []);\n  }\n\n  /**\n   * Gets the Resolvable that matches the token\n   *\n   * Gets the last Resolvable that matches the token in this context, or undefined.\n   * Throws an error if it doesn't exist in the ResolveContext\n   */\n  getResolvable(token: any): Resolvable {\n    const matching = this._path\n      .map((node) => node.resolvables)\n      .reduce(unnestR, [])\n      .filter((r: Resolvable) => r.token === token);\n    return tail(matching);\n  }\n\n  /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n  getPolicy(resolvable: Resolvable): ResolvePolicy {\n    const node = this.findNode(resolvable);\n    return resolvable.getPolicy(node.state);\n  }\n\n  /**\n   * Returns a ResolveContext that includes a portion of this one\n   *\n   * Given a state, this method creates a new ResolveContext from this one.\n   * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n   *\n   * #### Why\n   *\n   * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n   * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n   * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n   * This method is used to create a narrower context when injecting ancestor nodes.\n   *\n   * @example\n   * `let ABCD = new ResolveContext([A, B, C, D]);`\n   *\n   * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n   * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n   * However, `B` should only be able to access resolvables from `A`, `B`.\n   *\n   * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n   * `let AB = ABCD.subcontext(a)`\n   */\n  subContext(state: StateObject): ResolveContext {\n    return new ResolveContext(PathUtils.subPath(this._path, (node) => node.state === state));\n  }\n\n  /**\n   * Adds Resolvables to the node that matches the state\n   *\n   * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n   * The resolvable is added to the node matching the `state` parameter.\n   *\n   * These new resolvables are not automatically fetched.\n   * The calling code should either fetch them, fetch something that depends on them,\n   * or rely on [[resolvePath]] being called when some state is being entered.\n   *\n   * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n   *\n   * @param newResolvables the new Resolvables\n   * @param state Used to find the node to put the resolvable on\n   */\n  addResolvables(newResolvables: Resolvable[], state: StateObject) {\n    const node = <PathNode>find(this._path, propEq('state', state));\n    const keys = newResolvables.map((r) => r.token);\n    node.resolvables = node.resolvables.filter((r) => keys.indexOf(r.token) === -1).concat(newResolvables);\n  }\n\n  /**\n   * Returns a promise for an array of resolved path Element promises\n   *\n   * @param when\n   * @param trans\n   * @returns {Promise<any>|any}\n   */\n  resolvePath(when: PolicyWhen = 'LAZY', trans?: Transition): Promise<{ token: any; value: any }[]> {\n    // This option determines which 'when' policy Resolvables we are about to fetch.\n    const whenOption: string = inArray(ALL_WHENS, when) ? when : 'LAZY';\n    // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n    // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n    const matchedWhens = whenOption === resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n\n    // get the subpath to the state argument, if provided\n    trace.traceResolvePath(this._path, when, trans);\n\n    const matchesPolicy = (acceptedVals: string[], whenOrAsync: 'when' | 'async') => (resolvable: Resolvable) =>\n      inArray(acceptedVals, this.getPolicy(resolvable)[whenOrAsync]);\n\n    // Trigger all the (matching) Resolvables in the path\n    // Reduce all the \"WAIT\" Resolvables into an array\n    const promises: Promise<any>[] = this._path.reduce((acc, node) => {\n      const nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n      const nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n      const wait = nodeResolvables.filter(not(matchesPolicy(['NOWAIT'], 'async')));\n\n      // For the matching Resolvables, start their async fetch process.\n      const subContext = this.subContext(node.state);\n      const getResult = (r: Resolvable) =>\n        r\n          .get(subContext, trans)\n          // Return a tuple that includes the Resolvable's token\n          .then((value) => ({ token: r.token, value: value }));\n      nowait.forEach(getResult);\n      return acc.concat(wait.map(getResult));\n    }, []);\n\n    // Wait for all the \"WAIT\" resolvables\n    return services.$q.all(promises);\n  }\n\n  injector(): UIInjector {\n    return this._injector || (this._injector = new UIInjectorImpl(this));\n  }\n\n  findNode(resolvable: Resolvable): PathNode {\n    return find(this._path, (node: PathNode) => inArray(node.resolvables, resolvable));\n  }\n\n  /**\n   * Gets the async dependencies of a Resolvable\n   *\n   * Given a Resolvable, returns its dependencies as a Resolvable[]\n   */\n  getDependencies(resolvable: Resolvable): Resolvable[] {\n    const node = this.findNode(resolvable);\n    // Find which other resolvables are \"visible\" to the `resolvable` argument\n    // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n    const subPath: PathNode[] = PathUtils.subPath(this._path, (x) => x === node) || this._path;\n    const availableResolvables: Resolvable[] = subPath\n      .reduce((acc, _node) => acc.concat(_node.resolvables), []) // all of subpath's resolvables\n      .filter((res) => res !== resolvable); // filter out the `resolvable` argument\n\n    const getDependency = (token: any) => {\n      const matching = availableResolvables.filter((r) => r.token === token);\n      if (matching.length) return tail(matching);\n\n      const fromInjector = this.injector().getNative(token);\n      if (isUndefined(fromInjector)) {\n        throw new Error('Could not find Dependency Injection token: ' + stringify(token));\n      }\n\n      return new Resolvable(token, () => fromInjector, [], fromInjector);\n    };\n\n    return resolvable.deps.map(getDependency);\n  }\n}\n\n/** @internal */\nclass UIInjectorImpl implements UIInjector {\n  native: $InjectorLike;\n\n  constructor(public context: ResolveContext) {\n    this.native = this.get(NATIVE_INJECTOR_TOKEN) || services.$injector;\n  }\n\n  get(token: any) {\n    const resolvable = this.context.getResolvable(token);\n    if (resolvable) {\n      if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n        return resolvable.get(this.context);\n      }\n\n      if (!resolvable.resolved) {\n        throw new Error('Resolvable async .get() not complete:' + stringify(resolvable.token));\n      }\n      return resolvable.data;\n    }\n\n    return this.getNative(token);\n  }\n\n  getAsync(token: any) {\n    const resolvable = this.context.getResolvable(token);\n    if (resolvable) return resolvable.get(this.context);\n    return services.$q.when(this.native.get(token));\n  }\n\n  getNative(token: any) {\n    return this.native && this.native.get(token);\n  }\n}\n"
  ]
}