{
  "version": 3,
  "file": "stateQueueManager.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/state/stateQueueManager.ts"
  ],
  "names": [],
  "mappings": ";;;AAAA,oCAAoD;AAEpD,6CAA4C;AAM5C;IAGE,2BACU,MAAgB,EACjB,MAAsC,EACtC,OAAqB,EACrB,SAAkC;QAHjC,WAAM,GAAN,MAAM,CAAU;QACjB,WAAM,GAAN,MAAM,CAAgC;QACtC,YAAO,GAAP,OAAO,CAAc;QACrB,cAAS,GAAT,SAAS,CAAyB;QAN3C,UAAK,GAAkB,EAAE,CAAC;IAOvB,CAAC;IAEJ,mCAAO,GAAP;QACE,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;IAClB,CAAC;IAED,oCAAQ,GAAR,UAAS,SAA4B;QACnC,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;QACzB,IAAM,KAAK,GAAG,yBAAW,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QAC5C,IAAM,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;QAExB,IAAI,CAAC,iBAAQ,CAAC,IAAI,CAAC;YAAE,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;QACrE,IAAI,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,gBAAO,CAAC,KAAK,CAAC,GAAG,CAAC,aAAI,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC;YAC5E,MAAM,IAAI,KAAK,CAAC,YAAU,IAAI,yBAAsB,CAAC,CAAC;QAExD,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAClB,IAAI,CAAC,KAAK,EAAE,CAAC;QAEb,OAAO,KAAK,CAAC;IACf,CAAC;IAED,iCAAK,GAAL;QAAA,iBA2DC;QA1DO,IAAA,KAA6B,IAAI,EAA/B,KAAK,WAAA,EAAE,MAAM,YAAA,EAAE,OAAO,aAAS,CAAC;QACxC,IAAM,UAAU,GAAkB,EAAE,EAAE,6BAA6B;QACjE,OAAO,GAAkB,EAAE,EAAE,iDAAiD;QAC9E,mBAAmB,GAAG,EAAE,CAAC,CAAC,wEAAwE;QACpG,IAAM,QAAQ,GAAG,UAAC,IAAI,IAAK,OAAA,KAAI,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,KAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAArD,CAAqD,CAAC;QACjF,IAAM,eAAe,GAAG;YACtB,IAAI,UAAU,CAAC,MAAM,EAAE;gBACrB,KAAI,CAAC,SAAS,CAAC,OAAO,CAAC,UAAC,QAAQ;oBAC9B,OAAA,QAAQ,CACN,YAAY,EACZ,UAAU,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,IAAI,EAAN,CAAM,CAAC,CAC9B;gBAHD,CAGC,CACF,CAAC;aACH;QACH,CAAC,CAAC;QAEF,OAAO,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;YACvB,IAAM,KAAK,GAAgB,KAAK,CAAC,KAAK,EAAE,CAAC;YACzC,IAAM,MAAI,GAAG,KAAK,CAAC,IAAI,CAAC;YACxB,IAAM,MAAM,GAAgB,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YACjD,IAAM,SAAS,GAAW,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YAEjD,IAAI,MAAM,EAAE;gBACV,IAAM,aAAa,GAAG,QAAQ,CAAC,MAAI,CAAC,CAAC;gBACrC,IAAI,aAAa,IAAI,aAAa,CAAC,IAAI,KAAK,MAAI,EAAE;oBAChD,MAAM,IAAI,KAAK,CAAC,YAAU,MAAI,yBAAsB,CAAC,CAAC;iBACvD;gBAED,IAAM,mBAAmB,GAAG,QAAQ,CAAC,MAAI,GAAG,KAAK,CAAC,CAAC;gBACnD,IAAI,mBAAmB,EAAE;oBACvB,uCAAuC;oBACvC,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,UAAU,CAAC,mBAAmB,CAAC,CAAC;iBAC3D;gBAED,MAAM,CAAC,MAAI,CAAC,GAAG,KAAK,CAAC;gBACrB,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;gBACxB,IAAI,SAAS,IAAI,CAAC;oBAAE,OAAO,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;gBACjD,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACvB,SAAS;aACV;YAED,IAAM,IAAI,GAAG,mBAAmB,CAAC,MAAI,CAAC,CAAC;YACvC,mBAAmB,CAAC,MAAI,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC;YACzC,IAAI,SAAS,IAAI,CAAC,IAAI,IAAI,KAAK,KAAK,CAAC,MAAM,EAAE;gBAC3C,+FAA+F;gBAC/F,+DAA+D;gBAC/D,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAClB,eAAe,EAAE,CAAC;gBAClB,OAAO,MAAM,CAAC;aACf;iBAAM,IAAI,SAAS,GAAG,CAAC,EAAE;gBACxB,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aACrB;YAED,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACnB;QAED,eAAe,EAAE,CAAC;QAClB,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,uCAAW,GAAX,UAAY,KAAkB;QAC5B,IAAI,KAAK,CAAC,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG;YAAE,OAAO;QACzC,IAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC;QAC9C,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;IACvD,CAAC;IACH,wBAAC;AAAD,CAAC,AA/FD,IA+FC;AA/FY,8CAAiB",
  "sourcesContent": [
    "import { inArray, isString, prop } from '../common';\nimport { _StateDeclaration } from './interface';\nimport { StateObject } from './stateObject';\nimport { StateBuilder } from './stateBuilder';\nimport { StateRegistryListener } from './stateRegistry';\nimport { Disposable } from '../interface';\nimport { UIRouter } from '../router';\n\nexport class StateQueueManager implements Disposable {\n  queue: StateObject[] = [];\n\n  constructor(\n    private router: UIRouter,\n    public states: { [key: string]: StateObject },\n    public builder: StateBuilder,\n    public listeners: StateRegistryListener[]\n  ) {}\n\n  dispose() {\n    this.queue = [];\n  }\n\n  register(stateDecl: _StateDeclaration) {\n    const queue = this.queue;\n    const state = StateObject.create(stateDecl);\n    const name = state.name;\n\n    if (!isString(name)) throw new Error('State must have a valid name');\n    if (this.states.hasOwnProperty(name) || inArray(queue.map(prop('name')), name))\n      throw new Error(`State '${name}' is already defined`);\n\n    queue.push(state);\n    this.flush();\n\n    return state;\n  }\n\n  flush() {\n    const { queue, states, builder } = this;\n    const registered: StateObject[] = [], // states that got registered\n      orphans: StateObject[] = [], // states that don't yet have a parent registered\n      previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n    const getState = (name) => this.states.hasOwnProperty(name) && this.states[name];\n    const notifyListeners = () => {\n      if (registered.length) {\n        this.listeners.forEach((listener) =>\n          listener(\n            'registered',\n            registered.map((s) => s.self)\n          )\n        );\n      }\n    };\n\n    while (queue.length > 0) {\n      const state: StateObject = queue.shift();\n      const name = state.name;\n      const result: StateObject = builder.build(state);\n      const orphanIdx: number = orphans.indexOf(state);\n\n      if (result) {\n        const existingState = getState(name);\n        if (existingState && existingState.name === name) {\n          throw new Error(`State '${name}' is already defined`);\n        }\n\n        const existingFutureState = getState(name + '.**');\n        if (existingFutureState) {\n          // Remove future state of the same name\n          this.router.stateRegistry.deregister(existingFutureState);\n        }\n\n        states[name] = state;\n        this.attachRoute(state);\n        if (orphanIdx >= 0) orphans.splice(orphanIdx, 1);\n        registered.push(state);\n        continue;\n      }\n\n      const prev = previousQueueLength[name];\n      previousQueueLength[name] = queue.length;\n      if (orphanIdx >= 0 && prev === queue.length) {\n        // Wait until two consecutive iterations where no additional states were dequeued successfully.\n        // throw new Error(`Cannot register orphaned state '${name}'`);\n        queue.push(state);\n        notifyListeners();\n        return states;\n      } else if (orphanIdx < 0) {\n        orphans.push(state);\n      }\n\n      queue.push(state);\n    }\n\n    notifyListeners();\n    return states;\n  }\n\n  attachRoute(state: StateObject) {\n    if (state.abstract || !state.url) return;\n    const rulesApi = this.router.urlService.rules;\n    rulesApi.rule(rulesApi.urlRuleFactory.create(state));\n  }\n}\n"
  ]
}