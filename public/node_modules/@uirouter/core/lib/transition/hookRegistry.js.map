{
  "version": 3,
  "file": "hookRegistry.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/transition/hookRegistry.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "import { isString, isFunction, Glob, extend, removeFrom, tail, values, identity, mapObj } from '../common';\nimport { PathNode } from '../path/pathNode';\nimport {\n  TransitionStateHookFn,\n  TransitionHookFn,\n  TransitionHookPhase, // has or is using\n  TransitionHookScope,\n  IHookRegistry,\n  PathType,\n} from './interface';\n\nimport {\n  HookRegOptions,\n  HookMatchCriteria,\n  TreeChanges,\n  HookMatchCriterion,\n  IMatchingNodes,\n  HookFn,\n} from './interface';\nimport { Transition } from './transition';\nimport { StateObject } from '../state/stateObject';\nimport { TransitionEventType } from './transitionEventType';\nimport { TransitionService } from './transitionService';\n\n/**\n * Determines if the given state matches the matchCriteria\n *\n * @internal\n *\n * @param state a State Object to test against\n * @param criterion\n * - If a string, matchState uses the string as a glob-matcher against the state name\n * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n *   and returns a positive match if any of the globs match.\n * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n * @returns {boolean}\n */\nexport function matchState(state: StateObject, criterion: HookMatchCriterion, transition: Transition) {\n  const toMatch = isString(criterion) ? [criterion] : criterion;\n\n  function matchGlobs(_state: StateObject) {\n    const globStrings = <string[]>toMatch;\n    for (let i = 0; i < globStrings.length; i++) {\n      const glob = new Glob(globStrings[i]);\n\n      if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  const matchFn = <any>(isFunction(toMatch) ? toMatch : matchGlobs);\n  return !!matchFn(state, transition);\n}\n\n/**\n * The registration data for a registered transition hook\n */\nexport class RegisteredHook {\n  priority: number;\n  bind: any;\n  invokeCount = 0;\n  invokeLimit: number;\n  _deregistered = false;\n\n  constructor(\n    public tranSvc: TransitionService,\n    public eventType: TransitionEventType,\n    public callback: HookFn,\n    public matchCriteria: HookMatchCriteria,\n    public removeHookFromRegistry: (hook: RegisteredHook) => void,\n    options: HookRegOptions = {} as any\n  ) {\n    this.priority = options.priority || 0;\n    this.bind = options.bind || null;\n    this.invokeLimit = options.invokeLimit;\n  }\n\n  /**\n   * Gets the matching [[PathNode]]s\n   *\n   * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n   * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n   *\n   * Returning `null` is significant to distinguish between the default\n   * \"match-all criterion value\" of `true` compared to a `() => true` function,\n   * when the nodes is an empty array.\n   *\n   * This is useful to allow a transition match criteria of `entering: true`\n   * to still match a transition, even when `entering === []`.  Contrast that\n   * with `entering: (state) => true` which only matches when a state is actually\n   * being entered.\n   */\n  private _matchingNodes(nodes: PathNode[], criterion: HookMatchCriterion, transition: Transition): PathNode[] {\n    if (criterion === true) return nodes;\n    const matching = nodes.filter((node) => matchState(node.state, criterion, transition));\n    return matching.length ? matching : null;\n  }\n\n  /**\n   * Gets the default match criteria (all `true`)\n   *\n   * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n   *\n   * ```js\n   * {\n   *   to: true,\n   *   from: true,\n   *   entering: true,\n   *   exiting: true,\n   *   retained: true,\n   * }\n   */\n  private _getDefaultMatchCriteria(): HookMatchCriteria {\n    return mapObj(this.tranSvc._pluginapi._getPathTypes(), () => true);\n  }\n\n  /**\n   * Gets matching nodes as [[IMatchingNodes]]\n   *\n   * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n   *\n   * ```js\n   * let matches: IMatchingNodes = {\n   *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n   *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n   *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n   *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n   *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n   * };\n   * ```\n   */\n  private _getMatchingNodes(treeChanges: TreeChanges, transition: Transition): IMatchingNodes {\n    const criteria = extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n    const paths: PathType[] = values(this.tranSvc._pluginapi._getPathTypes());\n\n    return paths.reduce((mn: IMatchingNodes, pathtype: PathType) => {\n      // STATE scope criteria matches against every node in the path.\n      // TRANSITION scope criteria matches against only the last node in the path\n      const isStateHook = pathtype.scope === TransitionHookScope.STATE;\n      const path = treeChanges[pathtype.name] || [];\n      const nodes: PathNode[] = isStateHook ? path : [tail(path)];\n\n      mn[pathtype.name] = this._matchingNodes(nodes, criteria[pathtype.name], transition);\n      return mn;\n    }, {} as IMatchingNodes);\n  }\n\n  /**\n   * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n   *\n   * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n   * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n   */\n  matches(treeChanges: TreeChanges, transition: Transition): IMatchingNodes {\n    const matches = this._getMatchingNodes(treeChanges, transition);\n\n    // Check if all the criteria matched the TreeChanges object\n    const allMatched = values(matches).every(identity);\n    return allMatched ? matches : null;\n  }\n\n  deregister() {\n    this.removeHookFromRegistry(this);\n    this._deregistered = true;\n  }\n}\n\n/** Return a registration function of the requested type. */\nexport function makeEvent(\n  registry: IHookRegistry,\n  transitionService: TransitionService,\n  eventType: TransitionEventType\n) {\n  // Create the object which holds the registered transition hooks.\n  const _registeredHooks = (registry._registeredHooks = registry._registeredHooks || {});\n  const hooks = (_registeredHooks[eventType.name] = []);\n  const removeHookFn: (hook: RegisteredHook) => void = removeFrom(hooks);\n\n  // Create hook registration function on the IHookRegistry for the event\n  registry[eventType.name] = hookRegistrationFn;\n\n  function hookRegistrationFn(matchObject, callback, options = {}) {\n    const registeredHook = new RegisteredHook(\n      transitionService,\n      eventType,\n      callback,\n      matchObject,\n      removeHookFn,\n      options\n    );\n    hooks.push(registeredHook);\n    return registeredHook.deregister.bind(registeredHook);\n  }\n\n  return hookRegistrationFn;\n}\n"
  ]
}