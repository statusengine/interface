{
  "version": 3,
  "file": "transitionHook.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/transition/transitionHook.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "import { TransitionHookOptions, HookResult, TransitionHookPhase } from './interface';\nimport { defaults, noop, silentRejection } from '../common/common';\nimport { fnToString, maxLength } from '../common/strings';\nimport { isPromise } from '../common/predicates';\nimport { is, parse } from '../common/hof';\nimport { trace } from '../common/trace';\nimport { services } from '../common/coreservices';\nimport { Rejection } from './rejectFactory';\nimport { TargetState } from '../state/targetState';\nimport { Transition } from './transition';\nimport { TransitionEventType } from './transitionEventType';\nimport { RegisteredHook } from './hookRegistry';\nimport { StateDeclaration } from '../state/interface';\n\nconst defaultOptions: TransitionHookOptions = {\n  current: noop,\n  transition: null,\n  traceData: {},\n  bind: null,\n};\n\nexport type GetResultHandler = (hook: TransitionHook) => ResultHandler;\nexport type GetErrorHandler = (hook: TransitionHook) => ErrorHandler;\n\nexport type ResultHandler = (result: HookResult) => Promise<HookResult>;\nexport type ErrorHandler = (error: any) => Promise<any>;\n\nexport class TransitionHook {\n  type: TransitionEventType;\n\n  /**\n   * These GetResultHandler(s) are used by [[invokeHook]] below\n   * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])\n   */\n  static HANDLE_RESULT: GetResultHandler = (hook: TransitionHook) => (result: HookResult) =>\n    hook.handleHookResult(result);\n\n  /**\n   * If the result is a promise rejection, log it.\n   * Otherwise, ignore the result.\n   */\n  static LOG_REJECTED_RESULT: GetResultHandler = (hook: TransitionHook) => (result: HookResult) => {\n    isPromise(result) && result.catch((err) => hook.logError(Rejection.normalize(err)));\n    return undefined;\n  };\n\n  /**\n   * These GetErrorHandler(s) are used by [[invokeHook]] below\n   * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])\n   */\n  static LOG_ERROR: GetErrorHandler = (hook: TransitionHook) => (error: any) => hook.logError(error);\n\n  static REJECT_ERROR: GetErrorHandler = (hook: TransitionHook) => (error: any) => silentRejection(error);\n\n  static THROW_ERROR: GetErrorHandler = (hook: TransitionHook) => (error: any) => {\n    throw error;\n  };\n\n  /**\n   * Chains together an array of TransitionHooks.\n   *\n   * Given a list of [[TransitionHook]] objects, chains them together.\n   * Each hook is invoked after the previous one completes.\n   *\n   * #### Example:\n   * ```js\n   * var hooks: TransitionHook[] = getHooks();\n   * let promise: Promise<any> = TransitionHook.chain(hooks);\n   *\n   * promise.then(handleSuccess, handleError);\n   * ```\n   *\n   * @param hooks the list of hooks to chain together\n   * @param waitFor if provided, the chain is `.then()`'ed off this promise\n   * @returns a `Promise` for sequentially invoking the hooks (in order)\n   */\n  static chain(hooks: TransitionHook[], waitFor?: Promise<any>): Promise<any> {\n    // Chain the next hook off the previous\n    const createHookChainR = (prev: Promise<any>, nextHook: TransitionHook) => prev.then(() => nextHook.invokeHook());\n    return hooks.reduce(createHookChainR, waitFor || services.$q.when());\n  }\n\n  /**\n   * Invokes all the provided TransitionHooks, in order.\n   * Each hook's return value is checked.\n   * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.\n   * If no hook returns a promise, then all hooks are processed synchronously.\n   *\n   * @param hooks the list of TransitionHooks to invoke\n   * @param doneCallback a callback that is invoked after all the hooks have successfully completed\n   *\n   * @returns a promise for the async result, or the result of the callback\n   */\n  static invokeHooks<T>(hooks: TransitionHook[], doneCallback: (result?: HookResult) => T): Promise<any> | T {\n    for (let idx = 0; idx < hooks.length; idx++) {\n      const hookResult = hooks[idx].invokeHook();\n\n      if (isPromise(hookResult)) {\n        const remainingHooks = hooks.slice(idx + 1);\n\n        return TransitionHook.chain(remainingHooks, hookResult).then(doneCallback);\n      }\n    }\n\n    return doneCallback();\n  }\n\n  /**\n   * Run all TransitionHooks, ignoring their return value.\n   */\n  static runAllHooks(hooks: TransitionHook[]): void {\n    hooks.forEach((hook) => hook.invokeHook());\n  }\n\n  constructor(\n    private transition: Transition,\n    private stateContext: StateDeclaration,\n    private registeredHook: RegisteredHook,\n    private options: TransitionHookOptions\n  ) {\n    this.options = defaults(options, defaultOptions);\n    this.type = registeredHook.eventType;\n  }\n\n  private isSuperseded = () => this.type.hookPhase === TransitionHookPhase.RUN && !this.options.transition.isActive();\n\n  logError(err): any {\n    this.transition.router.stateService.defaultErrorHandler()(err);\n  }\n\n  invokeHook(): Promise<HookResult> | void {\n    const hook = this.registeredHook;\n    if (hook._deregistered) return;\n\n    const notCurrent = this.getNotCurrentRejection();\n    if (notCurrent) return notCurrent;\n\n    const options = this.options;\n    trace.traceHookInvocation(this, this.transition, options);\n\n    const invokeCallback = () => hook.callback.call(options.bind, this.transition, this.stateContext);\n\n    const normalizeErr = (err) => Rejection.normalize(err).toPromise();\n\n    const handleError = (err) => hook.eventType.getErrorHandler(this)(err);\n\n    const handleResult = (result) => hook.eventType.getResultHandler(this)(result);\n\n    try {\n      const result = invokeCallback();\n\n      if (!this.type.synchronous && isPromise(result)) {\n        return result.catch(normalizeErr).then(handleResult, handleError);\n      } else {\n        return handleResult(result);\n      }\n    } catch (err) {\n      // If callback throws (synchronously)\n      return handleError(Rejection.normalize(err));\n    } finally {\n      if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {\n        hook.deregister();\n      }\n    }\n  }\n\n  /**\n   * This method handles the return value of a Transition Hook.\n   *\n   * A hook can return false (cancel), a TargetState (redirect),\n   * or a promise (which may later resolve to false or a redirect)\n   *\n   * This also handles \"transition superseded\" -- when a new transition\n   * was started while the hook was still running\n   */\n  handleHookResult(result: HookResult): Promise<HookResult> {\n    const notCurrent = this.getNotCurrentRejection();\n    if (notCurrent) return notCurrent;\n\n    // Hook returned a promise\n    if (isPromise(result)) {\n      // Wait for the promise, then reprocess with the resulting value\n      return result.then((val) => this.handleHookResult(val));\n    }\n\n    trace.traceHookResult(result, this.transition, this.options);\n\n    // Hook returned false\n    if (result === false) {\n      // Abort this Transition\n      return Rejection.aborted('Hook aborted transition').toPromise();\n    }\n\n    const isTargetState = is(TargetState);\n    // hook returned a TargetState\n    if (isTargetState(result)) {\n      // Halt the current Transition and redirect (a new Transition) to the TargetState.\n      return Rejection.redirected(result).toPromise();\n    }\n  }\n\n  /**\n   * Return a Rejection promise if the transition is no longer current due\n   * to a stopped router (disposed), or a new transition has started and superseded this one.\n   */\n  private getNotCurrentRejection() {\n    const router = this.transition.router;\n\n    // The router is stopped\n    if (router._disposed) {\n      return Rejection.aborted(`UIRouter instance #${router.$id} has been stopped (disposed)`).toPromise();\n    }\n\n    if (this.transition._aborted) {\n      return Rejection.aborted().toPromise();\n    }\n\n    // This transition is no longer current.\n    // Another transition started while this hook was still running.\n    if (this.isSuperseded()) {\n      // Abort this transition\n      return Rejection.superseded(this.options.current()).toPromise();\n    }\n  }\n\n  toString() {\n    const { options, registeredHook } = this;\n    const event = parse('traceData.hookType')(options) || 'internal',\n      context = parse('traceData.context.state.name')(options) || parse('traceData.context')(options) || 'unknown',\n      name = fnToString(registeredHook.callback);\n    return `${event} context: ${context}, ${maxLength(200, name)}`;\n  }\n}\n"
  ]
}