{
  "version": 3,
  "file": "urlRule.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/url/urlRule.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "import { StateDeclaration } from '../state';\nimport { UrlMatcher } from './urlMatcher';\nimport { isString, isDefined, isFunction } from '../common/predicates';\nimport { UIRouter } from '../router';\nimport { identity, extend } from '../common/common';\nimport { is, or, pattern } from '../common/hof';\nimport { StateObject } from '../state/stateObject';\nimport { RawParams } from '../params/interface';\nimport {\n  UrlRule,\n  UrlRuleMatchFn,\n  UrlRuleHandlerFn,\n  UrlRuleType,\n  UrlParts,\n  MatcherUrlRule,\n  StateRule,\n  RegExpRule,\n} from './interface';\n\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[StateObject]]\n */\nexport class UrlRuleFactory {\n  static isUrlRule = (obj) => obj && ['type', 'match', 'handler'].every((key) => isDefined(obj[key]));\n\n  constructor(public router: UIRouter) {}\n\n  compile(str: string) {\n    return this.router.urlMatcherFactory.compile(str);\n  }\n\n  create(\n    what: string | UrlMatcher | StateObject | StateDeclaration | RegExp | UrlRuleMatchFn,\n    handler?: string | UrlRuleHandlerFn\n  ): UrlRule {\n    const { isState, isStateDeclaration } = StateObject;\n    const makeRule = pattern([\n      [isString, (_what: string) => makeRule(this.compile(_what))],\n      [is(UrlMatcher), (_what: UrlMatcher) => this.fromUrlMatcher(_what, handler)],\n      [or(isState, isStateDeclaration), (_what: StateObject | StateDeclaration) => this.fromState(_what, this.router)],\n      [is(RegExp), (_what: RegExp) => this.fromRegExp(_what, handler)],\n      [isFunction, (_what: UrlRuleMatchFn) => new BaseUrlRule(_what, handler as UrlRuleHandlerFn)],\n    ]);\n\n    const rule = makeRule(what);\n    if (!rule) throw new Error(\"invalid 'what' in when()\");\n    return rule;\n  }\n\n  /**\n   * A UrlRule which matches based on a UrlMatcher\n   *\n   * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n   *\n   * ## Handler as a function\n   *\n   * If `handler` is a function, the function is invoked with:\n   *\n   * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n   * - url: the current Url ([[UrlParts]])\n   * - router: the router object ([[UIRouter]])\n   *\n   * #### Example:\n   * ```js\n   * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n   * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match); // '/home/123/456'\n   * ```\n   *\n   * ## Handler as UrlMatcher\n   *\n   * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n   * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n   * The url is replaced with the result.\n   *\n   * #### Example:\n   * ```js\n   * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n   * var handler = $umf.compile(\"/home/:fooId/:barId\");\n   * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match); // '/home/123/456'\n   * ```\n   */\n  fromUrlMatcher(urlMatcher: UrlMatcher, handler: string | UrlMatcher | UrlRuleHandlerFn): MatcherUrlRule {\n    let _handler: UrlRuleHandlerFn = handler as any;\n    if (isString(handler)) handler = this.router.urlMatcherFactory.compile(handler);\n    if (is(UrlMatcher)(handler)) _handler = (match: RawParams) => (handler as UrlMatcher).format(match);\n\n    function matchUrlParamters(url: UrlParts): RawParams {\n      const params = urlMatcher.exec(url.path, url.search, url.hash);\n      return urlMatcher.validates(params) && params;\n    }\n\n    // Prioritize URLs, lowest to highest:\n    // - Some optional URL parameters, but none matched\n    // - No optional parameters in URL\n    // - Some optional parameters, some matched\n    // - Some optional parameters, all matched\n    function matchPriority(params: RawParams): number {\n      const optional = urlMatcher.parameters().filter((param) => param.isOptional);\n      if (!optional.length) return 0.000001;\n      const matched = optional.filter((param) => params[param.id]);\n      return matched.length / optional.length;\n    }\n\n    const details = { urlMatcher, matchPriority, type: 'URLMATCHER' };\n    return extend(new BaseUrlRule(matchUrlParamters, _handler), details) as MatcherUrlRule;\n  }\n\n  /**\n   * A UrlRule which matches a state by its url\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromState($state.get('foo'), router);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match);\n   * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n   * ```\n   */\n  fromState(stateOrDecl: StateObject | StateDeclaration, router: UIRouter): StateRule {\n    const state = StateObject.isStateDeclaration(stateOrDecl) ? stateOrDecl.$$state() : stateOrDecl;\n\n    /**\n     * Handles match by transitioning to matched state\n     *\n     * First checks if the router should start a new transition.\n     * A new transition is not required if the current state's URL\n     * and the new URL are already identical\n     */\n    const handler = (match: RawParams) => {\n      const $state = router.stateService;\n      const globals = router.globals;\n      if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n        $state.transitionTo(state, match, { inherit: true, source: 'url' });\n      }\n    };\n\n    const details = { state, type: 'STATE' };\n    return extend(this.fromUrlMatcher(state.url, handler), details) as StateRule;\n  }\n\n  /**\n   * A UrlRule which matches based on a regular expression\n   *\n   * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n   *\n   * ## Handler as a function\n   *\n   * If `handler` is a function, the function is invoked with:\n   *\n   * - regexp match array (from `regexp`)\n   * - url: the current Url ([[UrlParts]])\n   * - router: the router object ([[UIRouter]])\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n   * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n   * var result = rule.handler(match); // '/home/bar'\n   * ```\n   *\n   * ## Handler as string\n   *\n   * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n   * The string is first interpolated using `string.replace()` style pattern.\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n   * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n   * var result = rule.handler(match); // '/home/bar'\n   * ```\n   */\n  fromRegExp(regexp: RegExp, handler: string | UrlRuleHandlerFn): RegExpRule {\n    if (regexp.global || regexp.sticky) throw new Error('Rule RegExp must not be global or sticky');\n\n    /**\n     * If handler is a string, the url will be replaced by the string.\n     * If the string has any String.replace() style variables in it (like `$2`),\n     * they will be replaced by the captures from [[match]]\n     */\n    const redirectUrlTo = (match: RegExpExecArray) =>\n      // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n      (handler as string).replace(/\\$(\\$|\\d{1,2})/, (m, what) => match[what === '$' ? 0 : Number(what)]);\n\n    const _handler = isString(handler) ? redirectUrlTo : handler;\n\n    const matchParamsFromRegexp = (url: UrlParts): RegExpExecArray => regexp.exec(url.path);\n\n    const details = { regexp, type: 'REGEXP' };\n    return extend(new BaseUrlRule(matchParamsFromRegexp, _handler), details) as RegExpRule;\n  }\n}\n\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n * @internal\n */\nexport class BaseUrlRule implements UrlRule {\n  $id: number;\n  priority: number;\n  _group: number;\n  type: UrlRuleType = 'RAW';\n  handler: UrlRuleHandlerFn;\n  matchPriority = (match) => 0 - this.$id;\n\n  constructor(public match: UrlRuleMatchFn, handler?: UrlRuleHandlerFn) {\n    this.handler = handler || identity;\n  }\n}\n"
  ]
}